<html>
<head>
<title>Programming in C++, Rules and Recommendations</title>
</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<BR><h1>Programming in C++, Rules and Recommendations</h1>
<BR>FN/Mats Henricson and Erik Nyquist
<BR><P>Copyright (C) 1990-1992 by
<BR><P><address>
<BR>Ellemtel Telecommunication Systems Laboratories
<BR>Box 1505
<BR>125 25 Älvsjö
<BR>Sweden
<BR>Tel: int + 46 8 727 30 00
<BR></address>
<BR>
<P><I>Ath:</I> þessari HTML útgáfu af R&R var hnuplað frá Plús Plús hf. 
Þeir eiga allan heiðurinn af henni!
<BR>
(Sorry, no translation for the sentence about the conversion to HTML.)
<P>
Permission is granted to any individual or institution to use,
copy, modify, and distribute this document, provided that this
complete copyright and permission notice is maintained intact in all
copies. 
<P>Ellemtel Telecommunication Systems Laboratories makes no
representations about the suitability of this document or the examples
described herein for any purpose. It is provided "as is" without any
expressed or implied warranty. 
<BR>
<BR>Original translation from Swedish by Joseph Supanich
<P>
<P>
<UL>
<A NAME="BackToIndex"><h1>Table of Contents</h1></A>
<UL>
<BR>1  <a href="#introduction">Introduction</a>
<BR>2  <a href="#terminology">Terminology</a>
<BR>3  <a href="#GeneralRec">General Recommendations</a>
<BR>4  <a href="#SourceCode">Source Code in Files</a>
<BR>4.1  <a href="#StructureOf">Structure of Code</a>
<BR>4.2  <a href="#NamingFiles">Naming Files</a>
<BR>4.3  <a href="#Comments">Comments</a>
<BR>4.4  <a href="#IncludeFiles">Include Files</a>
<BR>5  <a href="#AssigningNames">Assigning Names</a>
<BR>6  <a href="#Style">Style</a>
<BR>6.1  <a href="#Style_Classes">Classes</a>
<BR>6.2  <a href="#Style_Functions">Functions</a>
<BR>6.3  <a href="#CompoundStatements">Compound Statements</a>
<BR>6.4  <a href="#FlowControl">Flow Control Statements</a>
<BR>6.5  <a href="#Pointers">Pointers and References</a>
<BR>6.6  <a href="#Misc">Miscellaneous</a>
<BR>7  <a href="#Classes">Classes</a>
<BR>7.1  <a href="#Considerations">Considerations Regarding Access Rights</a>
<BR>7.2  <a href="#InlineFunctions">Inline Functions</a>
<BR>7.3  <a href="#Friends">Friends</a>
<BR>7.4  <a href="#constMember">const Member Functions</a>
<BR>7.5  <a href="#Constructors">Constructors and Destructors</a>
<BR>7.6  <a href="#AssignmentOps">Assignment Operators</a>
<BR>7.7  <a href="#Operator">Operator Overloading</a>
<BR>7.8  <a href="#MemberFunc">Member Function Return Types</a>
<BR>7.9  <a href="#Inheritance">Inheritance</a>
<BR>8  <a href="#ClassTemplates">Class Templates</a>
<BR>9  <a href="#9_Functions">Functions</a>
<BR>9.1  <a href="#Functions_Arguments">Function Arguments</a>
<BR>9.2  <a href="#Functions_Overloading">Function Overloading</a>
<BR>9.3  <a href="#Formal_Arguments">Formal Arguments</a>
<BR>9.4  <a href="#ReturnTypes">Return Types and Values</a>
<BR>9.5  <a href="#InlineFunc">Inline Functions</a>
<BR>9.6  <a href="#TempObjects">Temporary Objects</a>
<BR>9.7  <a href="#General">General</a>
<BR>10  <a href="#Constants">Constants</a>
<BR>11  <a href="#Variables">Variables</a>
<BR>12  <a href="#Pointers_Rev">Pointers and References</a>
<BR>13  <a href="#Type_Conv">Type Conversions</a>
<BR>14  <a href="#Flow_Control">Flow Control Structures</a>
<BR>15  <a href="#Expressions">Expressions</a>
<BR>16  <a href="#MemAlloc">Memory Allocation</a>
<BR>17  <a href="#FaultHandling">Fault Handling</a>
<BR>18  <a href="#PortableCode">Portable Code</a>
<BR>18.1  <a href="#DataAbstract">Data Abstraction</a>
<BR>18.2  <a href="#TypeSizes">Sizes of Types</a>
<BR>18.3  <a href="#ConvTypes">Type Conversions</a>
<BR>18.4  <a href="#DataRep">Data Representation</a>
<BR>18.5  <a href="#UnderFlow">Underflow/Overflow</a>
<BR>18.6  <a href="#ExecOrder">Order of Execution</a>
<BR>18.7  <a href="#Objemp">Temporary Objects</a>
<BR>18.8  <a href="#PointAri">Pointer Arithmetic</a>
<BR>19  <a href="#Refs">References</a>
<BR>20  <a href="#RuleSummary">Summary of Rules</a>
<BR>21  <a href="#RecommendSum">Summary of Recommendations</a>
<BR>22  <a href="#PortSummary">Summary of Portability Recommendations</a>
</UL>
</UL>
<P>
<a name="introduction"><h2>1  Introduction </a>
</h2>
<P>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR>The purpose of this document is to define one style of programming
in C++. The rules and recommendations presented here are not final,
but should serve as a basis for continued work with C++. This
collection of rules should be seen as a dynamic document; suggestions
for improvements are encouraged. A form for requesting new rules or
changes to rules has been included as an appendix to this
document. Suggestions can also be made via e-mail to one of the
following addresses: 

<A HREF="mailto:erik.nyquist@eua.ericsson.se">erik.nyquist@eua.ericsson.se</A>
<BR>
<A HREF="mailto:mats.henricson@eua.ericsson.se">mats.henricson@eua.ericsson.se</A>
<P>
Programs that are developed according to these rules and
recommendations should be:
<UL>
<LI>  correct
<LI>  easy to maintain.
</UL>
In order to reach these goals, the programs should:
<UL>
<LI>  have a consistent style,
<LI>  be easy to read and understand,
<LI>  be portable to other architectures,
<LI>  be free of common types of errors,
<LI>  be maintainable by different programmers.
</UL>
<P>
Questions of design, such as how to design a class or a class
hierarchy, are beyond the scope of this document. Recommended books on
these subjects are indicated in the chapter entitled "References". 
<P>
In order to obtain insight into how to effectively deal with the most
difficult aspects of C++, the examples of code which are provided
should be carefully studied. C++ is a difficult language in which
there may be a very fine line between a feature and a bug. This places
a large responsibility upon the programmer. In the same way as for C,
C++ allows a programmer to write compact and, in some sense,
unreadable code.
<P>
Code written in bold type is meant to serve as a warning. The examples
often include class definitions having the format "class <name>
{};". These are included so that the examples may be compiled; it is
not recommended that class definitions be written in this way. In
order to make the code more compact, the examples provided do not
always follow the rules. In such cases, the rule which is broken is
indicated. 
<P>
Many different C++ implementations are in use today. Most are based on
the C++ Language System by AT&amp;T. The component of this product
which translates C++ code to C is called Cfront. The different
versions of Cfront (2.0, 2.1 &amp; 3.0 are currently in use) are
referred to in order to point out the differences between different
implementations. 
<P>
<b>Rule 0</b>   Every time a rule is broken, this must be clearly documented.
<P>
<a name="terminology"><h1>2  Terminology</a>
</h1> 
<a href="#BackToIndex">Back to index</a>
<OL>
<LI>  An identifier is a name which is used to refer to a variable,
constant, function or type in C++. When necessary, an identifier may
have an internal structure which consists of a prefix, a name, and a
suffix (in that order). 
<LI>  A class is a user-defined data type which consists of data
elements and functions which operate on that data. In C++, this may be
declared as a class; it may also be declared as a struct or a
union. Data defined in a class is called member data and functions
defined in a class are called member functions. 
<LI>  A class/struct/union is said to be an abstract data type if it
does not have any public or protected member data.  
<LI>  A structure is a user-defined type for which only public data is
specified. 
<LI>  Public members of a class are member data and member functions
which are everywhere accessible by specifying an instance of the class
and the name. 
<LI>  Protected members of a class are member data and member
functions which are accessible by specifying the name within member
functions of derived classes. 
<LI>  A class template defines a family of classes. A new class may be
created from a class template by providing values for a number of
arguments. These values may be names of types or constant
expressions. 
<LI>  A function template defines a family of functions. A new
function may be created from a function template by providing values
for a number of arguments. These values may be names of types or
constant expressions. 
<LI>  An enumeration type is an explicitly declared set of symbolic
integral constants. In C++ it is declared as an enum. 
<LI>  A typedef is another name for a data type, specified in C++
using a typedef declaration. 
<LI>  A reference is another name for a given variable. In C++, the
`address of' (&amp;) operator is used immediately after the data type
to indicate that the declared variable, constant, or function argument
is a reference. 
<LI>  A macro is a name for a text string which is defined in a
#define statement. When this name appears in source code, the compiler
replaces it with the defined text string. 
<LI>  A constructor is a function which initializes an object.
<LI>  A copy constructor is a constructor in which the first argument
is a reference to an object that has the same type as the object to be
initialized. 
<LI>  A default constructor is a constructor which needs no arguments.
<LI>  An overloaded function name is a name which is used for two or
more functions or member functions having different types. 
<LI>  An overridden member function is a member function in a base
class which is re-defined in a derived class. Such a member function
is declared virtual. 
<LI>  A pre-defined data type is a type which is defined in the
language itself, such as int. 
<LI>  A user-defined data type is a type which is defined by a
programmer in a class, struct, union, enum, or typedef definition or
as an instantiation of a class template. 
<LI>  A pure virtual function is a member function for which no
definition is provided. Pure virtual functions are specified in
abstract base classes and must be defined (overridden) in derived
classes. 
<LI>  An accessor is a function which returns the value of a data member.
<LI>  A forwarding function is a function which does nothing more than
call another function. 
<LI>  A constant member function is a function which may not modify
data members. 
<LI>  An exception is a run-time program anomaly that is detected in a
function or member function. Exception handling provides for the
uniform management of exceptions. When an exception is detected, it is
thrown (using a throw expression) to the exception handler.  
<LI>  A catch clause is code that is executed when an exception of a
given type is raised. The definition of an exception handler begins
with the keyword catch. 
<LI>  An abstract base class is a class from which no objects may be
created; it is only used as a base class for the derivation of other
classes. A class is abstract if it includes at least one member
function that is declared as pure virtual. 
<LI>  An iterator is an object which, when invoked, returns the next
object from a collection of objects. 
<LI>  The scope of a name refers to the context in which it is visible.
<LI>  A compilation unit is the source code (after preprocessing) that
is submitted to a compiler for compilation (including syntax
checking). 
</OL>
<P>
<a name="GeneralRec"><h1>3  General Recommendations </a>
</h1>
<a href="#BackToIndex">Back to index</a>

<P><b>Rec. 1</b>   Optimize code only if you know that you have a
performance problem. Think twice before you begin. 
<P><b>Rec. 2</b>   If you use a C++ compiler that is based on Cfront,
always compile with the +w flag set to eliminate as many warnings as
possible. 
<P>
Various tests are said to have demonstrated that programmers generally
spend a lot of time optimizing code that is never executed. If your
program is too slow, use gprof++ or an equivalent tool to determine
the exact nature of the problem before beginning to optimize. 
<P>
Code that is accepted by a compiler is not always correct (in
accordance with the definition of the C++ language). Two reasons for
this are that changes are made in the language and that compilers may
contain bugs. In the short term, very little can be done about the
latter. In order to reduce the amount of code that must be rewritten
for each new compiler release, it is common to let the compiler
provide warnings  instead of reporting errors for such code until the
next major release. Cfront provides the +w flag to direct the compiler
to give warnings for these types of language changes. 
<P>
<a name="SourceCode"><h1>4  Source Code in Files</a>
</h1>
<a href="#BackToIndex">Back to index</a>
<BR>
<a name = "StructureOf"><P><h2>4.1  Structure of Code</a>
</h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rule 1</b>   Include files in C++ always have the file name extension ".hh".
<P><b>Rule 2</b>   Implementation files in C++ always have the file name extension ".cc".
<P><b>Rule 3</b>   Inline definition files always have the file name extension ".icc".
<P><b>Rec. 3</b>   An include file should not contain more than one class definition.
<P><b>Rec. 4</b>   Divide up the definitions of member functions or functions into as many files as possible.
<P><b>Rec. 5</b>   Place machine-dependent code in a special file so
that it may be easily located when porting code from one machine to
another. 
<P>
The purpose of these conventions is to provide a uniform
interpretation of file names. One reason for this is that it is easier
to make tools which base their behaviour on the file name extension. 
<P>
There are two kinds of include files in C++: those which contain code
that is accepted by both ANSI-C and C++ compilers and those which
contain code that is only accepted by C++ compilers. It is appropriate
to distinguish between the two in order to avoid unpleasant
compilation errors (from using the wrong kind of include file). 
<P>
If a ".cc" file contains a large number of function definitions, the
object file produced by the compiler may be unnecessarily large. In
order to obtain the smallest possible executable files, it is
necessary to have a separate file for each function definition. This
is because the standard UNIX linker ld links all functions in an
object file even if only one of them is actually used. It is
especially important to remember that virtual functions are always
linked. On the other hand, there are problems in managing a large
number of files, since sufficiently powerful tools are not currently
available. Also, the time necessary to compile a program consisting of
a large number of files is longer. 
<P>
Some debuggers cannot debug inline functions. By placing inline
functions in a separate file and  by including that file in the
implementation file, thus treating the inline functions as ordinary
functions,  it is possible to debug the functions while testing the
program. For this to work some special preprocessor  techniques must
be used. The inline definition file must not be included by the
include file for the class and the keyword `inline' must be removed. 
<P>
When tools for managing C++ code are not available, it is much easier
for those who use and maintain classes if there is only one class
definition in each file and if implementations of member functions in
different classes are not present in the same file.
<P>
<P><i>Exception to Rule 1:</i>   Include files which contain code that
is accepted by both C and C++ compilers should have the file name
extension ".h". 
<P><i>Exception to Rule 2:</i>   When using a compiler that does not
accept the extension ".cc", the extension  ".C" is used instead. 
<P><i>Exception to Rule 3:</i>   No exceptions.
<P>
<P><b>Example 1</b>   Inline  definitions in a separate file for
conditional compilation 
<BR><pre>  // AnyClass.hh
  #ifndef OUTLINE
  #include "AnyClass.icc"
  #endif
        
  //AnyClass.cc
  #ifdef OUTLINE
  #define inline
  #include "AnyClass.icc"
  #undef inline
  #endif
</PRE>
<P>
<a name="NamingFiles"><h2>4.2  Naming Files</a>
</h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rec. 6</b>   Always give a file a name that is unique in as
large a context as possible. 
<P><b>Rec. 7</b>   An include file for a class should have a file name
of the form <class name> + extension. Use uppercase and lowercase
letters in the same way as in the source code. 
<P>There is always a risk for name collisions when the file name is
part of identifier names that are generated by the compiler. This is a
problem in using any Cfront-based compiler. 
<P>AT&amp;T's Cfront-based compiler creates two functions for every
file in order to call constructors and destructors of static objects
in the proper order. These functions are named: 
<P>char __sti__file_cc___Fv();  //filename is file.cc
<BR>char __std__file_cc___Fv();  //filename is file.cc
<BR>It is easily understood that if a program has two files with the
same name but in different subdirectories, there will be name
collisions between the functions generated above. 
<P>
Since class names must generally be unique within a large context, it
is appropriate to utilize this characteristic when naming its include
file. This convention makes it easy to locate a class definition using
a file-based tool. 
<P>
<a name="Comments"><h2>4.3 Comments</h2></a>
<a href="#BackToIndex">Back to index</a>
<BR>
<P><b>Rule 4</b>   Every file that contains source code must be
documented with an introductory comment that provides information on
the file name and its contents. 
<P><b>Rule 5</b>   All files must include copyright information.
<P><b>Rule 6</b>   All comments are to be written in English.
<P><b>Rec. 8</b>   Write some descriptive comments before every function.
<P><b>Rec. 9</b>   Use // for comments.
<P>It is necessary to document source code. This should be compact and
easy to find. By properly choosing names for variables, functions and
classes and by properly structuring the code,  there is less need for
comments within the code. 
<P>
Note that comments in include files are meant for the users of
classes, while comments in implementation files are meant for those
who maintain the classes. 
<P>
All our code must be copyright marked. If the code has been developed over a period of years, each year must be stated.
<P>
The standardization of comments makes it possible to automatically
generate man-pages from source code. This may be used to keep source
code and documentation together until adequate tools for information
management are available. 
<P>
Comments are often said to be either strategic or tactical. A
strategic comment describes what a function or section of code is
intended to do, and is placed before this code. A tactical comment
describes what a single line of code is intended to do, and is placed,
if possible, at the end of this line. Unfortunately, too many tactical
comments can make code unreadable. For this reason, it is recommended
to primarily use strategic comments, unless trying to explain very
complicated code.  
<P>
If the characters // are consistently used for writing comments, then
the combination /* */ may be used to make comments out of entire
sections of code during the development and debugging phases. C++,
however, does not allow comments to be nested using /* */.
<P>
<P><i>Exception to Rule 4:</i>   No exceptions.
<P><i>Exception to Rule 5:</i>   No exceptions.
<P><i>Exception to Rule 6:</i>   No exceptions.
<P>
<P><b>Example 2</b>   Documentation of a file
<BR><pre>  //
  //  File:   test.cc
  //  Description: This is a test program
  //  Rev:   A
  //  Created:   Thur. Oct 31, 1991, 12:30:14
  //  Author:   Erik Nyquist
  //  mail:   erik.nyquist@eua.ericsson.se
  //
  //  Copyright Ellemtel Utvecklings AB 1991
  //  BOX 1505
  //  125 25 ALVSJO
  //  SWEDEN
  //  tel int + 46 8 727 3000
  //
  //  The copyright to the computer program(s) herein
  //  is the property of Ellemtel Utvecklings AB, Sweden.
  //  The program(s) may be used and/or copied  only with
  //  the written permission of  Ellemtel Utvecklings AB
  //  or in accordance   with the terms and conditions
  //  stipulated   in the agreement/contract under which
  //  the  program(s) have been supplied.
  //
        
</pre><P><b>Example 3</b>   Strategic and Tactical Comments
<BR><pre>  // THE NEXT TWO LINES ARE STRATEGIC COMMENTS
  // This function does some complicated things. It works like this:
  //  blah-blah-blah ...
  int
  insanelyGreatAndComplicatedFunction( int i )
  {
    int index = i++ + ++i * i-- - --i;  // THIS IS A TACTICAL COMMENT
        
    return index;
  }
        
</pre><P>
<a name="IncludeFiles"><h2>4.4  Include Files</a>
</h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rule 7</b>   Every include file must contain a mechanism that prevents multiple inclusions of the file.
<P><b>Rule 8</b>   When the following kinds of definitions are used
(in implementation files or in other include files), they must be
included as separate include files: 
<UL>
<LI> classes that are used as base classes,
<LI> classes that are used as member variables,
<LI> classes that appear as return types or as argument types in
function/member function prototypes. 
<LI> function prototypes for functions/member functions used in inline
member functions  that are defined in the file. 
</UL>
<P><b>Rule 9</b>   Definitions of classes that are only accessed via
pointers (*) or references (&amp;) shall not be included as include
files. 
<P><b>Rule 10</b>  Never specify relative UNIX names in #include directives.
<P><b>Rule 11</b>  Every implementation file is to include the
relevant files that contain:
<UL>
<LI> declarations of types and functions used in the functions that are implemented in the file.
<LI>  declarations of variables and member functions used in the
functions that are implemented in the file. 
</UL>
<P><b>Rec. 10</b>  Use the directive #include "filename.hh" for user-prepared include files.
<P><b>Rec. 11</b>  Use the directive #include <filename.hh> for include files from libraries.
<P><b>Rec. 12</b>  Every implementation file should declare a local
constant string that describes the file so the UNIX command what can
be used to obtain information on the file revision. 
<P><b>Rec. 13</b>  Never include other files in an ".icc" file.
<P>
The easiest way to avoid multiple includes of files is by using an
#ifndef/#define block in the beginning of the file and an #endif at
the end of the file. 
<P>
The number of files included should be minimized. If a file is
included in an include file, then every implementation file that
includes the second include file must be re-compiled whenever the
first file is modified. A simple modification in one include file can
make it necessary to re-compile a large number of files.
<P>
When only referring to pointers or references to types defined in a
file, it is often not necessary to include that file. It may suffice
to use a forward declaration to inform the compiler that the class
exists. Another alternative is to precede each declaration of a
pointer to the class with the keyword class. 
<P>
True portable code is independent of the underlying operating
system. For this reason, relative UNIX search paths should be avoided
when including files. The processing of such search paths depends on
the compiler and UNIX should not be taken for granted. Instead, search
paths should be provided in `make' files as options for the compiler. 
<P>
If a file only contains information that is only needed in an
implementation file, that file should not be included in another
include file. Otherwise, when the information is no longer needed in
the implementation file, it may be necessary to re-compile each file
that uses the interface defined in the include file. 
<P>
Every C++ course teaches the difference between the include directives
for user-prepared and for library include files. If the file name is
bracketed between "<" and ">", the preprocessor will not search for
the file in the default directory. This reduces the risk of unintended
name collisions between user-prepared and library include files. 
<P>
By declaring a local constant string, the compiler becomes
self-identifying. This may be used to easily determine the version of
the program that is used. The string must begin with the characters
@(#) to be read by the UNIX what command. 
<P>
<P><i>Exception to Rule 7:</i>   No exceptions.
<P><i>Exception to Rule 8:</i>   No exceptions.
<P><i>Exception to Rule 9:</i>   No exceptions.
<P><i>Exception to Rule 10:</i>   No exceptions.
<P><i>Exception to Rule 11:</i>   No exceptions.
<P>
<P><b>Example 4</b>   Technique for preventing multiple inclusion of an include file
<BR><pre>  #ifndef FOO_HH
  #define FOO_HH
        
  // The rest of the file
        
  #endif
        
</pre><P><b>Example 5</b>   Never use explicit UNIX path names
<BR><pre>  // NOT RECOMMENDED
  #include <../include/fnutt.h>
        
  // NOT GUARANTEED TO WORK
  #include <sys/socket.h>
        
</pre><P><b>Example 6</b>   Local constant string for identifying implementation files.
<BR><pre>  static const char* sccsid = 
  "@(#) Exception.cc, rev. A, Copyright Ellemtel Utvecklings AB 1991";
        
</pre><P><b>Example 7</b>   Include file for the class PackableString
<BR><pre>  // file: PackableString.hh
  #ifndef PACKABLESTRING_HH
  #define PACKABLESTRING_HH

  #include "String.hh"
  #include "Packable.hh"
        
  // It is not necessary to extern-declare class Buffer when
  // each pointer declaration specifies the keyword class as shown below.
  // An explicit extern-declaration makes the code easier to 
  // understand.
        
  extern class Buffer;
        
  class PackableString : public String, public Packable
  {
    public:
      PackableString( const String&amp; s );
      class Buffer* put( class Buffer* outbuffer );
      // ...
  };
        
  #endif
        
</pre><P><b>Example 8</b>   Implementation file for the class PackableString
<BR><pre>  // PackableString.cc
        
  #include "PackableString.hh"
        
  // To be able to use Buffer-instances, Buffer.hh MUST be included.
        
  #include "Buffer.hh"
        
  Buffer*           
  PackableString::put( Buffer* outbuffer )
  {
    // ...
  }
        
</pre><P>
<a name="AssigningNames"><h1>5  Assigning Names</h1></a>
<a href="#BackToIndex">Back to index</a>
<P><b>Rule 12</b>  The identifier of every globally visible class,
enumeration type, type definition, function, constant, and variable in
a class library is to begin with a prefix that is unique for the
library. 
<P><b>Rule 13</b>  The names of variables, constants, and functions
are to begin with a lowercase letter. 
<P><b>Rule 14</b>  The names of abstract data types, structures,
typedefs, and enumerated types are to begin with an uppercase letter. 
<P><b>Rule 15</b>  In names which consist of more than one word, the
words are written together and each word that follows the first is
begun with an uppercase letter. 
<P><b>Rule 16</b>  Do not use identifiers which begin with one or two
underscores (`_' or `__'). 
<P><b>Rule 17</b>  A name that begins with an uppercase letter is to
appear directly after its prefix. 
<P><b>Rule 18</b>  A name that begins with a lowercase letter is to be
separated from its prefix using an underscore (`_'). 
<P><b>Rule 19</b>  A name is to be separated from its suffix using an
underscore (`_'). 
<P><b>Rec. 14</b>  Do not use typenames that differ only by the use of
uppercase and lowercase letters. 
<P><b>Rec. 15</b>  Names should not include abbreviations that are not
generally accepted. 
<P><b>Rec. 16</b>  A variable with a large scope should have a long name.
<P><b>Rec. 17</b>  Choose variable names that suggest the usage.
<P><b>Rec. 18</b>  Write code in a way that makes it easy to change
the prefix for global identifiers. 
<P><b>Rec. 19</b>  Encapsulate global variables and constants,
enumerated types, and typedefs in a class. 
<P>
In this chapter, it is important to distinguish between identifiers
and names. The  name is that part of an identifier that shows its
meaning. An identifier consists of a prefix, a name, and a suffix (in
that order). The prefix and the suffix are optional. A suffix is only
used by tools that generate C++ code, to avoid name collisions with
user-written C++ code and is not given further consideration here. 
<P>
It is recommended identifiers not be extremely long, to reduce the
risk for name collisions when using tools that truncate long
identifiers.  
<P>
The Unix command ar truncates file names that are longer than 15
characters. front normally modifies generated C-identifiers that are
longer than 31 characters by truncating them and adding a hash value
that is generated from the truncated part of the string. 
<P>
The use of two underscores (`__') in identifiers is reserved for the
compiler's internal use according to the ANSI-C standard. 
<P>
Underscores (`_') are often used in names of library functions (such
as " _main" and "_exit"). In order to avoid collisions, do not begin
an identifier with an underscore. 
<P>
One rule of thumb is that a name which cannot be pronounced is a bad
name. A long name is normally better than a short, cryptic name, but
the truncation problem must be taken into consideration. Abbreviations
can always be misunderstood. Global variables, functions and constants
ought to have long enough names to avoid name conflicts, but not too
long. 
<P>
Classes should be named so that "object.function" is easy to read and
appears to be logical. 
<P>
There are many class libraries available for purchase and there may
be tens of thousands of classes in a large project!! Because of this,
it is important to be careful that name collisions do not occur. One
way of preventing collisions is to have strict rules for assigning
names to globally visible objects (such as our use of a prefix). In
this way, classes from several different class libraries may be used
at the same time. 
<P>Names for the following types of objects are to be prefixed:
<UL>
<LI>  Type names (classes, typedefs, enums, structs, unions, etc.)
<LI>  Global variables and constants
<LI>  Function names (not member functions names)
<LI>  Preprocessor macros (#define)
</UL>
The use of prefixes can sometimes be avoided by using a class to limit
the scope of the name. Static variables in a class should be used
instead of global variables and constants, enumerated data types, and
typedefs. Although nested classes may be used in C++, these give rise
to too many questions (in connection with the language definition) to
be able to recommend their use. 
<P>
<P><i>Exception to Rule 12:</i>   No exceptions.
<P><i>Exception to Rule 13:</i>   No exceptions. (At times, an
identifier begins with an abbreviation written in uppercase letters,
to emphasize the way in which the name is used. Such an abbreviation
is considered to be a prefix). 
<P><i>Exception to Rule 14:</i>   If the last letter in a word is in
uppercase, an underscore is to be used as a word separator. 
<P><i>Exception to Rule 15:</i>   No exceptions.
<P><i>Exception to Rule 16:</i>   No exceptions.
<P><i>Exception to Rule 17:</i>   No exceptions.
<P><i>Exception to Rule 18:</i>   No exceptions.
<P><i>Exception to Rule 19:</i>   No exceptions.
<P>
<P><b>Example 9</b>   Exception using compound names
<BR><pre>  const char* functionTitle = "EUA_Special";
  int currentIO_Stream = 1; // Last Character in currentIO is in uppercase!
        
</pre><P><b>Example 10</b>   Choice of names
<BR><pre>  int groupID;      // instead of grpID
  int nameLength;     // instead of namLn
  PrinterStatus resetPrinter;  // instead of rstprt
        
</pre><P><b>Example 11</b>   Ambiguous names
<BR><pre>  void termProcess();    // Terminate process or 
          // terminal process?
                
</pre><P><b>Example 12</b>   Names having numeric characters can cause errors which are difficult to locate.
<BR><pre>  int I0 = 13;      // Names with digits can be
  int IO = I0;      // difficult to read.
        
</pre><P><b>Example 13</b>   Definition of a class in the class library Emc2
<BR><pre>  class Emc2Class
  {
    public:
      Emc2Class();  // Default constructor
      // ...
    private:
      int id;
      // ...
  };
        
</pre><P><b>Example 14</b>   One way to avoid global functions and classes
<BR><pre>  // Instead of declaring:
  void Emc2_myFunc1();
  void Emc2_myFunc2();
  class Emc2MyClass { /* ... */ };
        
  // Encapsulate the functions using an abstract class:
  class Emc2
  {
    public:
      static void myFunc1();
      static void myFunc2();
      class MyClass { /* ... */ };
    private:
      virtual dummy() = 0;     // Trick to make the class abstract
  };
        
  // Now, functions and classes may be accessed by using the scope-operator:
  Emc2::myFunc1();
  Emc2::myFunc2();
  Emc2::MyClass myObject;
        
</pre><P>
<a name="Style"><h1>6  Style</h1></a>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><P>
<a name="Style_Classes"><h2>6.1  Classes</a>
</h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rule 20</b>  The public, protected, and private sections of a
class are to be declared in that order (the public section is declared
before the protected section which is declared before the private
section). 
<P><b>Rule 21</b>  No member functions are to be defined within the
class definition. 
<P>
By placing the public section first, everything that is of interest to
a user is gathered in the beginning of the class definition. The
protected section may be of interest to designers when considering
inheriting from the class. The private section contains details that
should have the least general interest. 
<P>
A member function that is defined within a class definition
automatically becomes inline. Class definitions are less compact and
more difficult to read when they include definitions of member
functions. It is easier for an inline member function to become an
ordinary member function if the definition of the inline function is
placed outside of the class definition. This rule will be in effect at
least as long as traditional text editors are used. 
<P>
A similar problem is that members are private if no access specifier
is explicitly given. This problem is avoided by following Rule 20. 
<P>
<P><i>Exception to Rule 20:</i>   No exceptions.
<P><i>Exception to Rule 21:</i>   No exceptions.
<P>
<P><b>Example 15</b>   A class definition in accordance with the style rules
<BR><pre>  class String : private Object
  {
    public:
      String();         // Default constructor
      String( const String&amp; s );   // Copy constructor
      unsigned length() const;
      // ...
    protected:
      int checkIndex( unsigned index ) const;
      // ...
    private:
      unsigned noOfChars;
      // ...
  };
        
</pre><P><b>Example 16</b>   No definitions of member functions within the class definition (See Example 1)
<BR><pre>  // Instead of writing like this:
  class String
  {
    public:
      int length() const // No !!
        { 
          return len; 
        }   
      // ...
    private:
      int len;
  };
        
  // Do it this way:
  class String 
  {
    public:
      int length() const;   
      // ...
    private:
      int len;
  };
        
  inline 
  int 
  String::length() const       
  {
    return len;
  }
        
</pre><P>
<a name="Style_Functions"><h2>6.2  Functions</a>
</h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rec. 20</b>  Always provide the return type of a function explicitly.
<P><b>Rec. 21</b>  When declaring functions, the leading parenthesis
and the first argument (if any) are to be written on the same line as
the function name. If space permits, other arguments and the closing
parenthesis may also be written on the same line as the function
name. Otherwise, each additional argument is to be written on a
separate line (with the closing parenthesis directly after the last
argument). 
<P><b>Rec. 22</b>  In a function definition, the return type of the
function should be written on a separate line directly above the
function name. 
<P><b>Rec. 23</b>  Always write the left parenthesis directly after a
function name. 
<P>
If no return type is explicitly provided for a function, it is, by
default, an int. It is recommended to always provide the return type
explicitly, to increase the readability of the code. By defining the
return type on a separate line directly above the function definition,
the function name is more easily seen. 
<P>
The other recommendations are meant to give a uniform appearance to
the code that is written. Until such time as formatting tools are
available, programmers should follow these guidelines. 
<P>
<P><b>Example 17</b>   The left parenthesis always directly after the
function name 
<BR>
<pre>
  void foo ();  // No!!
  void foo();  // Better
</pre>
<P><b>Example 18</b>   Right and wrong ways of declaring formal
arguments for a function (in function definition) 
<BR>
<pre>
  // Right:
  int
  myComplicatedFunction( unsigned unsignedValue,
                int intValue,
                char* charPointerValue,
                int* intPointerValue,
                myClass* myClassPointerValue,
                unsigned* unsignedPointerValue );
        
  // Wrong:
  int
  myComplicatedFunction( unsigned unsignedValue, int intValue,
  char* charPointerValue, int* intPointerValue, myClass* myClassPointerValue,
  unsigned* unsignedPointerValue );
</pre>
<P>
<a name="CompoundStatements"><h2>6.3  Compound Statements</a>
</h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rec. 24</b>  Braces ("{}") which enclose a block are to be
placed in the same column, on separate lines directly before and after
the block. 
<P>
The placement of braces seems to have been the subject of the
greatest debate concerning the appearance of both C and C++ code. We
recommend the style which, in our opinion, gives the most readable
code. Other styles may well provide more compact code. 
<P><P>
<a name="FlowControl"><h2>6.4  Flow Control Statements</a>
</h2>
<a href="#BackToIndex">Back to index</a>

<P><b>Rec. 25</b>  The flow control primitives if, else, while, for
and do should be followed by a  block, even if it is an empty block. 
<P>
At times, everything that is to be done in a loop may be easily
written on one line in the loop statement itself. It may then be
tempting to conclude the statement with a semicolon at the end of the
line. This may lead to misunderstanding since, when reading the code,
it is easy to miss such a semicolon. It seems to be better, in such
cases, to place an empty block after the statement to make completely
clear what the code is doing. 
<P>
<P><b>Example 19</b>   Flow control structure without statements
<BR>
<pre>
  // No block at all - No!
  while ( /* Something */ );
        
  // Empty block - better!
  while ( /* Something */ )
  {
    // Empty !
  }
</pre>
<P>
<a name="Pointers"><h2>6.5  Pointers and References</a></h2>
<a href="#BackToIndex">Back to index</a><BR>
<BR><b>Rec. 26</b>  The dereference operator `*' and the address-of operator `&amp;' should be directly connected with the type names in declarations and definitions.
<P>
The characters `*' and `&amp;' should be written together with the
types of variables instead of with the names of variables in order to
emphasize that they are part of the type definition. Instead of saying
that *i is an int, say that i is an int*. 
<P>
Traditionally, C recommendations indicate that `*' should be written
together with the variable name, since this reduces the probability of
making a mistake when declaring several variables in the same
declaration statement (the operator `*' only applies to the variable
on which it operates). Since the declaration of several variables in
the same statement is not recommended, however, such a advice is
unneeded. 
<P>
<P><b>Example 20</b>   * and &amp; together with the type
<BR>
<pre>
  char* 
  Object::asString()
  {
    // Something
  };
        
  char* userName = 0;
  int sfBook = 42;
  int&amp;  anIntRef = sfBook;
</pre>
<P><b>Example 21</b>   Declaration of several variables in the same statement
<BR><pre>  // NOT RECOMMENDED
  char* i,j; // i is declared pointer to char, while j is declared char
        
</pre><P>
<a name="Misc"><h2>6.6  Miscellaneous</a></h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rec. 27</b>  Do not use spaces around `.' or `->', nor between unary operators and operands.
<P><b>Rec. 28</b>  Use the c++ mode in GNU Emacs to format code.
<P>
In our opinion, code is more readable if spaces are not used around
the . or -> operators. The same applies to unary operators (those that
operate on one operand), since a space may give the impression that
the unary operand is actually a binary operator. 
<P>
Ordinary spaces should be used instead of tabs. Since different
editors treat tab characters differently, the work in perfecting a
layout may have been wasted if another editor is later used. Tab
characters can be removed using the UNIX command expand. One
alternative is to format code using the editor GNU Emacs. 
<P>
We recommend that everyone use GNU Emacs to format code. Code will
then have a uniform appearance regardless of who has written it.
<P>
<a name="Classes"><h1>7  Classes</h1></a>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><P>
<a name="Considerations"><h2>7.1  Considerations Regarding Access Rights</a></h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rule 22</b>  Never specify public or protected member data in a class.
<P>
The use of public variables is discouraged for the following reasons:
<OL>
<LI>  A public variable represents a violation of one of the basic
principles of object-oriented programming, namely, encapsulation of
data. For example, if there is a class of the type BankAccount, in
which account_balance is a public variable, the value of this variable
may be changed by any user of the class. However, if the variable has
been declared private, its value may be changed only by the member
functions of the class. 
<LI>  An arbitrary function in a program can change public data which
may lead to errors that are difficult to locate. 
<LI> If public data is avoided, its internal representation may be
changed without users of the class having to modify their code. A
principle of class design is to maintain the stability of the public
interface of the class. The implementation of a class should not be a
concern for its users. 
</OL>
<P> 
The use of protected variables in a class are not recommended,
since its variables become visible to its derived classes. The names
of types or variables in a base class may then not be changed since
the derived classes may depend on them. If a derived class, for some
reason, must access data in its base class, one solution may be to
make a special protected interface in the base class, containing
functions which return private data. This solution would not imply any
degradation of performance if the functions are defined inline. 
<P>
The use of structs is also discouraged since these only contain public
data. In interfaces with other languages (such as C), it may, however,
be necessary to use structs. 
<P>
<P><i>Exception to Rule 22:</i>   In interfaces with other languages
(such as C), it may be necessary to use structs having public data. 
<P>
<P><b>Example 22</b>   The correct way to encapsulate data so that
future changes are possible. 
<BR><pre>
  // Original class:
        
  class Symbol {};
  class OldSymbol : public Symbol {};
        
  class Priority
  { 
    public:
      // returns pd
      int priority();
        
      // returns symbol
      class Symbol* getSymbol() const;
      // ...
    private:
      int pd;
      OldSymbol symbol; 
  };
        
        
  // Modified class:
  // The programmer has chosen to change the private data from an int
  // to an enum. A user of the class `Priority' does not have to change
  // any code, since the enum return-value from the member function
  // priority() is automatically converted to an int.
        
  class Symbol {};
  class NewSymbol : public Symbol {};
  enum Priority { low, high, urgent };
        
  class Priority
  {
    public:
      // Interface intact through implicit cast, returns priority_data
      Priority priority();
      
      // Interface intact, object of new subclass to symbol returned
      class Symbol* getSymbol() const;
      // ...
        
    private:
      Priority priority_data; // New representation/name of internal data
      NewSymbol symbol;
  };
        
</pre><P>
<a name="InlineFunctions"><h2>7.2  Inline Functions</a></h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rec. 29</b>  Access functions are to be inline.
<P><b>Rec. 30</b>  Forwarding functions are to be inline.
<P><b>Rec. 31</b>  Constructors and destructors must not be inline.
<P>
The normal reason for declaring a function inline is to improve its
performance. 
<P>
Small functions, such as access functions, which return the value of a
member of the class and so-called forwarding functions which invoke
another function should normally be inline.  
<P>
Correct usage of inline functions may also lead to reduced size of
code. 
<BR>
Warning: functions, which invoke other inline functions, often become
too complex for the complier to be able to make them inline despite
their apparent smallness. 
<P>
This problem is especially common with constructors and destructors. A
constructor always invokes the constructors of its base classes and
member data before executing its own code. Always avoid inline
constructors and destructors! 
<P><P>
<a name="Friends"><h2>7.3  Friends</a></h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rec. 32</b>  Friends of a class should be used to provide additional functions that are best kept outside of the class. 
<P>
Operations on an object are sometimes provided by a collection of
classes and functions. 
<P>
A friend is a nonmember of a class, that has access to the nonpublic
members of the class. Friends offer an orderly way of getting around
data encapsulation for a class. A friend class can be advantageously
used to provide functions which require data that is not normally
needed by the class. 
<P>
Suppose there is a list class which needs a pointer to an internal
list element in order to iterate through the class. This pointer is
not needed for other operations on the list. There may then be reason,
such as obtaining smaller list objects, for an list object not to
store a pointer to the current list element and instead to create an
iterator, containing such a pointer, when it is needed. 
<P>
One problem with this solution is that the iterator class normally
does not have access to the data structures which are used to
represent the list (since we also recommend private member data). 
<P>
By declaring the iterator class as a friend, this problem is avoided
without violating data encapsulation. 
<P>
Friends are good if used properly. However, the use of many friends
can indicate that the modularity of the system is poor. 
<P>
<a name="constMember"><h2>7.4  const Member Functions</a></h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rule 23</b>  A member function that does not affect the state
of an object (its instance variables) is to be declared const. 
<P><b>Rule 24</b>  If the behaviour of an object is dependent on data
outside the object, this data is not to be modified by const member
functions. 
<P>
Member functions declared as const may not modify member data and are
the only functions which may be invoked on a const object. (Such an
object is clearly unusable without const methods). A const declaration
is an excellent insurance that objects will not be modified (mutated)
when they should not be. A great advantage that is provided by C++ is
the ability to overload functions with respect to their
const-ness. (Two member functions may have the same name where one is
const and the other is not). 
<P>
Non-const member functions are sometimes invoked as so-called
'lvalues' (as a location value at which a value may be stored). A
const member function may never be invoked as an 'lvalue'. 
<P>
The behaviour of an object can be affected by data outside the
object. Such data must not be modified by a const member function. 
<P>
At times, it is desirable to modify data in a const object (such a
having a cache of data for performance reasons). In order to avoid
explicit type conversions from a const type to a non-const type, the
only way is to store the information outside the object. (See example
55). This type of data should be seen as external data which does not
affect the behaviour of the class. 
<P>
<P><i>Exception to Rule 23:</i>   No exceptions.
<P><i>Exception to Rule 24:</i>   No exceptions. 
<P>
<P><b>Example 23</b>   const-declared access functions to internal data in a class
<BR><pre>  class SpecialAccount : public Account
  {
    public:
      int insertMoney();
      // int getAmountOfMoney();  No! Forbids ANY constant object to
      //          access the amount of money.
      int getAmountOfMoney() const;  // Better!
      // ...
    private:
      int moneyAmount;
  };
        
</pre><P><b>Example 24</b>   Overloading an operator/function with
respect to const-ness 
<BR><pre>  #include <iostream.h>
  #include <string.h>
  static unsigned const cSize = 1024;
  class InternalData {};
        
  class Buffer
  {
    public:
      Buffer( char* cp );
        
      // Inline functions in this class are written compactly so the example
      // may fit on one page. THIS is NOT to be done in practice (See Rule 21).
        
      // A. non-const member functions: result is an lvalue
      char&amp; operator[]( unsigned index ) { return buffer[index]; }   
      InternalData&amp; get() { return data; }
     
      // B. const member functions: result is not an lvalue
      char operator[]( unsigned index ) const { return buffer[index]; }
      const InternalData&amp; get() const { return data; }
        
    private:
      char buffer[cSize];
      InternalData data;
  };
        
  inline Buffer::Buffer( char* cp )
  {
     strncpy( buffer , cp , sizeof( buffer ) );
  }
        
  main()
  {
     const Buffer cfoo = "peter";                   // This is a constant buffer
     Buffer foo = "mary";                   // This buffer can change
          
     foo[2]='c';                    // calls char&amp; Buffer::operator[](unsigned)
    cfoo[2] = 'c'                  // ERROR: cfoo[2] is not an lvalue.
          
    // cfoo[2] means that Buffer::operator[](unsigned) const is called.
          
     cout &lt< cfoo[2] &lt< ":" &lt< foo[2] &lt< endl; // OK! Only rvalues are needed
          
    foo.get() = cfoo.get(); 
    cfoo.get() = foo.get();                   // ERROR: cfoo.get() is not an lvalue 
  }
        
</pre><P>
<a name="Constructors"><h2>7.5  Constructors and Destructors</a></h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rule 25</b>  A class which uses "new" to allocate instances
managed by the class,  must define a copy constructor. 
<P><b>Rule 26</b>  All classes which are used as base classes and
which have virtual functions, must define a virtual destructor. 
<P><b>Rec. 33</b>  Avoid the use of global objects in constructors and
destructors. 
<P>
A copy constructor is recommended to avoid surprises when an object is
initialized using an object of the same type. If an object manages the
allocation and deallocation of an object on the heap (the managing
object has a pointer to the object to be created by the class'
constructor), only the value of the pointer will be copied. This can
lead to two invocations of the destructor for the same object (on the
heap), probably resulting in a run-time error.  
<P>
The corresponding problem exists for the assignment operator
(`='). See 7.6: Assignment Operators. 
<P>
If a class, having virtual functions but without virtual destructors,
is used as a base class, there may be a surprise if pointers to the
class are used. If such a pointer is assigned to an instance of a
derived class and if delete is then used on this pointer, only the
base class' destructor will be invoked. If the program depends on the
derived class' destructor being invoked, the program will fail. 
<P>
In connection with the initialization of statically allocated objects,
it is not certain that other static objects will be initialized (for
example, global objects). This is because the order of initialization
of static objects which is defined in various compilation units, is
not defined in the language definition. There are ways of avoiding
this problem, all of which require some extra work. 
<P>
You must know what you are doing if you invoke virtual functions from
a constructor in the class. If virtual functions in a derived class
are overridden, the original definition in the base class will still
be invoked by the base class' constructor. Override, then, does not
always work when invoking virtual functions in constructors. See
Example 30. 
<P><i>Exception to Rule 25:</i>   Sometimes, it is desired to let
objects in a class share a data area. In such a case, it is not
necessary to define a copy constructor. Instead, it is necessary to
make sure that this data area is not deallocated as long as there are
pointers to it. 
<P>
<P><i>Exception to Rule 26:</i>   No exceptions.
<P>
<P><b>Example 25</b>   Definition of a "dangerous" class not having a copy constructor
<BR><pre>  #include <string.h>
        
  class String
  {
    public:
      String( const char* cp = "");   // Constructor
      ~String();       // Destructor
      // ...
    private:
      char* sp;
      // ...
  };
        
  String::String(const char* cp) : sp( new char[strlen(cp)] )  // Constructor
  {
    strcpy(sp,cp);
  }
        
  String::~String()    // Destructor
  {
    delete sp;
  }
        
  // "Dangerous" String class
  void
  main() 
  {
    String w1;
    String w2 = w1;
    // WARNING: IN A BITWISE COPY OF w1::sp,
    // THE DESTRUCTOR FOR W1::SP WILL BE CALLED TWICE:
    // FIRST, WHEN w1 IS DESTROYED; AGAIN, WHEN w2 IS DESTROYED.
  }
        
</pre><P><b>Example 26</b>   "Safe" class having copy constructor and default constructor
<BR><pre>  #include <string.h>
        
  class String
  {
    public:
      String( const char* cp = "");  // Constructor
      String( const String&amp; sp );  // Copy constructor
      ~String();      // Destructor
      // ...
    private:
      char* sp;
      // ...
  };
        
  String::String( const char* cp ) : sp( new char[strlen(cp)] )   // Constructor
  {
    strcpy(sp,cp);
  }
        
  String::String( const String&amp; stringA ) : sp( new char[strlen(stringA.sp)] )
  {
    strcpy(sp,stringA.sp);
  }
        
  String::~String()     // Destructor
  {
    delete sp;
  }
        
  // "Safe" String class
  void
  main() 
  {
    String w1;
    String w2 = w1;   // SAFE COPY: String::String( const String&amp; ) CALLED.
  }
        
</pre><P><b>Example 27</b>   Definitions of classes not having virtual destructors
<BR><pre>  class Fruit
  {
    public:
      ~Fruit();     // Forgot to make destructor virtual!!
      // ...
  };
        
  class Apple : public Fruit
  {
    public:
      ~Apple();     // Destructor
      // ...
  };
        
  // "Dangerous" usage of pointer to base class
        
  class FruitBasket 
  {
    public:
      FruitBasket();            // Create FruitBasket
      ~FruitBasket();           // Delete all fruits
      // ...
      void add(Fruit*);            // Add instance allocated on the free store
      // ...
    private:
      Fruit* storage[42]; // Max 42 fruits stored
      int numberOfStoredFruits;
  };      
        
  void
  FruitBasket::add(Fruit* fp)
  {
    // Store pointer to fruit
    storage[numberOfStoredFruits++] = fp;
  }
        
  FruitBasket::FruitBasket() : numberOfStoredFruits(0)
  {
  }
        
  FruitBasket::~FruitBasket()
  {
    while (numberOfStoredFruits&gt0)        
    {
       delete storage[--numberOfStoredFruits]; // Only Fruit::~Fruit is called !!
    }
  }
        
</pre><P><b>Example 28</b>   Dangerous use of static objects in constructors
<BR><pre>  // Hen.hh
  class Egg;
        
  class Hen 
  {
    public:
      Hen();    // Default constructor
      ~Hen();   // Destructor
      // ...
      void makeNewHen(Egg*);
      // ...
  };      
        
  // Egg.hh
        
  class Egg { };
        
  extern Egg theFirstEgg; // defined in Egg.cc
        
  // FirstHen.hh
        
  class FirstHen : public Hen
  {
    public:
      FirstHen();    // Default constructor
      // ...
  };
        
  extern FirstHen theFirstHen; // defined in FirstHen.cc
        
  // FirstHen.cc
        
  FirstHen theFirstHen; // FirstHen::FirstHen() called
        
  FirstHen::FirstHen() 
  {
    // The constructor is risky because theFirstEgg is a global object 
    // and may not yet exist when theFirstHen is initialized.
    // Which comes first, the chicken or the egg ?
        
    makeNewHen(&amp;theFirstEgg);
  }
        
</pre><P><b>Example 29</b>   One way of ensuring that global objects have been initialized
<BR><pre>  // WARNING!!! THIS CODE IS NOT FOR BEGINNERS !!!
        
  // PortSetup.hh
        
  class PortSetup
  {
    public:
      PortSetup();        // Constructor: initializes flag
      void foo();          // Only works correctly if flag is 42
    private:
      int flag;          // Always initialized to 42
  };
        
  extern PortSetup portSetup;  // Must be initialized before use
        
  // Create one instance of portSetupInit in each translation unit
  // The constructor for portSetupInit will be called once for each
  // translation unit. It initializes portSetup by using the placement
  // syntax for the "new" operator.
        
  static 
  class PortSetupInit
  {
    public:
      PortSetupInit();     // Default constructor
    private:
      static int isPortSetup;
  } portSetupInit;
        
  // PortSetup.cc
        
  #include "PortSetup.hh"
  #include <new.h>
        
  // ...
        
  PortSetupInit::PortSetupInit()   // Default constructor
  { 
    if (!isPortSetup) 
    {
      new (&amp;portSetup) PortSetup; 
      isPortSetup = 1;
    }
  }
        
        
</pre><P><b>Example 30</b>   Override of virtual functions does not work in the base class' constructors
<BR><pre>  class Base
  {
    public:
      Base();       // Default constructor
      virtual void foo() { cout &lt< "Base::foo" &lt< endl; }
      // ...
  };
        
  Base::Base()
  {
    foo();     // Base::foo() is ALWAYS called.
  }
        
  // Derived class overrides foo()
  class Derived : public Base
  {
    public:
      virtual void foo() { cout &lt< "Derived::foo" &lt< endl; } //foo is overridden
      // ...
  };
        
  main()
  {
    Derived d;        // Base::foo() called when the Base-part of 
            // Derived is constructed.
  }
        
        
</pre><P>
<a name="AssignmentOps"><h2>7.6  Assignment Operators</a></h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rule 27</b>  A class which uses "new" to allocate instances
managed by the class,  must define an assignment operator. 
<P><b>Rule 28</b>  An assignment operator which performs a destructive
action must be protected from performing this action on the object
upon which it is operating. 
<P><b>Rec. 34</b>  An assignment operator ought to return a const
reference to the assigning object. 
<P>
An assignment is not inherited like other operators. If an assignment
operator is not explicitly defined, then one is automatically defined
instead. Such an assignment operator does not perform bit-wise copying
of member data; instead, the assignment operator (if defined) for each
specific type of member data is invoked. Bit-wise copying is only
performed for member data having primitive types. 
<P>
One consequence of this is that bit-wise copying is performed for
member data having pointer types. If an object manages the allocation
of the instance of an object pointed to by a pointer member, this will
probably lead to problems: either by invoking the destructor for the
managed object more than once or by attempting to use the deallocated
object. See also Rule 25. 
<P>
If an assignment operator is overloaded, the programmer must make
certain that the base class' and the members' assignment operators are
run. 
<P>
A common error is assigning an object to itself (a = a). Normally,
destructors for instances which are allocated on the heap are invoked
before assignment takes place. If an object is assigned to itself, the
values of the instance variables will be lost before they are
assigned. This may well lead to strange run-time errors. If a = a is
detected, the assigned object should not be changed. 
<P>
If an assignment operator returns "void", then it is not possible to
write a = b = c. It may then be tempting to program the assignment
operator so that it returns a reference to the assigning
object. Unfortunately, this kind of design can be difficult to
understand. The statement (a = b) = c can mean that a or b is assigned
the value of c before or after a is assigned the value of b. This type
of code can be avoided by having the assignment operator return a
const reference to the assigned object or to the assigning
object. Since the returned object cannot be placed on the left side of
an assignment, it makes no difference which of them is returned (that
is, the code in the above example is no longer correct). 
<P><i>Exception to Rule 27:</i>   Sometimes, it is desirable to allow
objects in a class to share a data area. In such cases, it is not
necessary to define an assignment operator. Instead, it is necessary
to make sure that the shared data area is no deallocated as long as
there are pointers to it. 
<P><i>Exception to Rule 28:</i>   No exceptions.
<P>
<P><b>Example 31</b>   Incorrect and correct return values from an assignment operator
<BR><pre>  void
  MySpecialClass::operator=( const MySpecialClass&amp; msp );      // Well ...?
        
  MySpecialClass&amp;
  MySpecialClass::operator=( const MySpecialClass&amp; msp );      // No!
        
  const MySpecialClass&amp;
  MySpecialClass::operator=( const MySpecialClass&amp; msp );      // Recommended
        
</pre><P><b>Example 32</b>   Definition of a class with an overloaded assignment operator
<BR><pre>  class DangerousBlob
  {
    public:
      const DangerousBlob&amp; operator=( const DangerousBlob&amp; dbr );
      // ...
    private:
      char* cp;
  };
        
  // Definition of assignment operator
        
  const DangerousBlob&amp;
  DangerousBlob::operator=( const DangerousBlob&amp; dbr )
  {
    if ( this != &amp;dbr )    // Guard against assigning to the "this" pointer
    {
      delete cp;     // Disastrous if this == &amp;dbr
    }
    // ...
  }
        
</pre><P>
<a name="Operator"><h2>7.7  Operator Overloading</a></h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rec. 35</b>  Use operator overloading sparingly and in a uniform manner.
<P><b>Rec. 36</b>  When two operators are opposites (such as == and
!=), it is appropriate to define both. 
<P>
Operator overloading has both advantages and disadvantages. One
advantage is that code which uses a class with overloaded operators
can be written more compactly (more readably). Another advantage is
that the semantics can be both simple and natural. One disadvantage in
overloading operators is that it is easy to misunderstand the meaning
of an overloaded operator (if the programmer has not used natural
semantics). The extreme case, where the plus-operator is re-defined to
mean minus and the minus-operator is re-defined to mean plus, probably
will not occur very often, but more subtle cases are conceivable. 
<P>
Designing a class library is like designing a language! If you use
operator overloading, use it in a uniform manner; do not use it if it
can easily give rise to misunderstanding. 
<P>
If the operator != has been designed for a class, then a user may well
be surprised if the operator == is not defined as well. 
<P>
<a name="MemberFunc"><h2>7.8  Member Function Return Types</a></h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rule 29</b>  A public member function must never return a
non-const reference or pointer to member data. 
<P><b>Rule 30</b>  A public member function must never return a
non-const reference or pointer to data outside an object, unless the
object shares the data with other objects. 
<P>By allowing a user direct access to the private member data of an
object, this data may be changed in ways not intended by the class
designer. This may lead to reduced confidence in the designer's code:
a situation to be avoided. 
<P>
A worse risk is having pointers which point to deallocated memory.
Rule 29 and Rule 30 attempt to avoid this situation. 
<P>
Note that we do not forbid the use of protected member functions which
return a const reference or pointer to member data. If protected
access functions are provided, the problems described in 7.1 are
avoided. 
<P>
<P><i>Exception to Rule 29:</i>   No exceptions.
<P><i>Exception to Rule 30:</i>   No exceptions.
<P>
<P><b>Example 33</b>   Never return a non-const reference to member
data from a public function. 
<BR><pre>  class Account
  {
    public:
      Account( int myMoney ) : moneyAmount( myMoney ) {};
      const int&amp; getSafeMoney() const { return moneyAmount; }
      int&amp; getRiskyMoney() const { return moneyAmount; }   // No!
      // ...
    private:
      int moneyAmount;
  };
        
  Account myAcc(10);   // I'm a poor lonesome programmer a long way from home
        
  myAcc.getSafeMoney() += 1000000;  // Compilation error: assignment to constant
        
  myAcc.getRiskyMoney() += 1000000; // myAcc::moneyAmount = 1000010 !!
        
</pre><P>
<a name = "Inheritance"><h2>7.9  Inheritance</a>
</h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rec. 37</b>  Avoid inheritance for parts-of relations.
<P><b>Rec. 38</b>  Give derived classes access to class type member
data by declaring protected access functions. 
<P>
A common mistake is to use multiple inheritance for parts-of relations
(when an object consists of several other objects, these are inherited
instead of using instance variables. This can result in strange class
hierarchies and less flexible code. In C++ there may be an arbitrary
number of instances of a given type; if inheritance is used, direct
inheritance from a class may only be used once. 
<P>
A derived class often requires access to base class member data in
order to create useful member functions. The advantage in using
protected member functions is that the names of base class member data
are not visible in the derived classes and thus may be changed. Such
access functions should only return the values of member data
(read-only access). This is best done by simply invoking const
functions for the member data. 
<P>
The guiding assumption is that those who use inheritance know enough
about the base class to be able to use the private member data
correctly, while not referring to this data by name. This reduces the
coupling between base classes and derived classes. 
<P>
<a name="ClassTemplates"><h1>8  Class Templates</h1></a>
<a href="#BackToIndex">Back to index</a>
<P><b>Rec. 39</b>  Do not attempt to create an instance of a class
template using a type that does not define the member functions which
the class template, according to its documentation,  requires. 
<P><b>Rec. 40</b>  Take care to avoid multiple definition of
overloaded functions in conjunction with the instantiation of a class
template. 
<P>
It is not possible in C++ to specify requirements for type arguments
for class templates and function templates. This may imply that the
type chosen by the user, does not comply with the interface as
required by the template. For example, a class template may require
that a type argument have a comparison operator defined. 
<P>
Another problem with type templates can arise for overloaded
functions. If a function is overload, there may be a conflict if the
element type appears explicitly in one of these. After instantiation,
there may be two functions which, for example, have the type int as an
argument. The compiler may complain about this, but there is a risk
that the designer of the class does not notice it. In cases where
there is a risk for multiple definition of member functions, this must
be carefully documented.
<P>
<P><b>Example 34</b>   Problem when using parameterized types (Cfront 3.0 or other template compiler)
<BR><pre>  template <class ET> 
  class Conflict
  {
    public:
      void foo( int a );
      void foo( ET a );    // What if ET is an int or another integral type?
               // The compiler will discover this, but ...
  };
        
</pre><P>
<a name="9_Functions"><h1>9  Functions</h1></a>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR>Unless otherwise stated, the following rules also apply to member functions.
<BR><P>
<a name="Functions_Arguments"><h2>9.1  Function Arguments</a></h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rule 31</b>  Do not use unspecified function arguments (ellipsis notation).
<P><b>Rec. 41</b>  Avoid functions with many arguments.
<P><b>Rec. 42</b>  If a function stores a pointer to an object which
is accessed via an argument, let the argument have the type
pointer. Use reference arguments in other cases. 
<P><b>Rec. 43</b>  Use constant references (const &amp;) instead of
call-by-value, unless using a pre-defined data type or a pointer. 
<P>
The best known function which uses unspecified arguments is
printf(). The use of such functions is not advised since the strong
type checking provided by C++ is thereby avoided. Some of the
possibilities provided by unspecified function arguments can be
attained by overloading functions and by using default arguments. 
<P>
Functions having long lists of arguments look complicated, are
difficult to read, and can indicate poor design. In addition, they are
difficult to use and to maintain. 
<P>
By using references instead of pointers as function arguments, code
can be made more readable, especially within the function. A
disadvantage is that it is not easy to see which functions change the
values of their arguments. Member functions which store pointers which
have been provided as arguments should document this clearly by
declaring the argument as a pointer instead of as a reference. This
simplifies the code, since it is normal to store a pointer member as a
reference to an object. 
<P>
One difference between references and pointers is that there is no
null-reference in the language, whereas there is a null-pointer. This
means that an object must have been allocated before passing it to a
function. The advantage with this is that it is not necessary to test
the existence of the object within the function. 
<P>
C++ invokes functions according to call-by-value. This means that the
function arguments are copied to the stack via invocations of copy
constructors, which, for large objects, reduces performance. In
addition, destructors will be invoked when exiting the function. const
&amp; arguments mean that only a reference to the object in question
is placed on the stack (call-by-reference) and that the object's state
(its instance variables) cannot be modified. (At least some const
member functions are necessary for such objects to be at all useful). 
<P><i>Exception to Rule 31:</i>   No exceptions.
<P>
<P><b>Example 35</b>   References instead of pointers
<BR><pre>  // Unnecessarily complicated use of pointers
  void addOneComplicated( int* integerPointer )
  { 
    *integerPointer += 1;
  }
        
  addOneComplicated( &amp;j );
        
  // Write this way instead:
  void addOneEasy( int&amp; integerReference )
  { 
    integerReference += 1;
  }
        
  addOneEasy( i );
        
</pre><P><b>Example 36</b>   Different mechanisms for passing arguments
<BR><pre>  // a. A copy of the argument is created on the stack.
  //    The copy constructor is called on entry,
  //    and the destructor is called at exit from the function.
  //    This may lead to very inefficient code.
        
  void foo1( String s );
  String a;
  foo1( a );     // call-by-value
        
  // b. The actual argument is used by the function
  //    and it can be modified by the function.
        
  void foo2( String&amp; s );
  String b;
  foo2( b );    // call-by-reference
        
  // c. The actual argument is used by the function
  //    but it cannot be modified by the function.
        
  void foo3( const String&amp; s );
  String c;
  foo3( c );    // call-by-constant-reference
        
  // d. A pointer to the actual argument is used by the function.
  //    May lead to messy syntax when the function uses the argument.
        
  void foo4( const String* s );
  String d;
  foo4( &amp;d );    // call-by-constant-pointer
        
</pre><P>
<a name="Functions_Overloading"><h2>9.2  Function Overloading</a></h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rec. 44</b>  When overloading functions, all variations should
have the same semantics (be used for the same purpose). 
<P>
Overloading of functions can be a powerful tool for creating a family
of related functions that only differ as to the type of data provided
as arguments. If not used properly (such as using functions with the
same name for different purposes), they can, however, cause
considerable confusion. 
<P>
<P><b>Example 37</b>   Example of the proper usage of function overloading
<BR><pre>  class String
  {
    public:              // Used like this:
      // ...            // String x = "abc123";
      int contains( const char c );      // int i = x.contains( 'b' );
      int contains( const char* cs );     // int j = x.contains( "bc1" );
      int contains( const String&amp; s );    // int k = x.contains( x );
      // ...
  };
        
</pre><P>
<a name="Formal_Arguments"><h2>9.3  Formal Arguments</a></h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rule 32</b>  The names of formal arguments to functions are to
be specified and are to be the same both in the function declaration
and in the function definition. 
<P>
The names of formal arguments may be specified in both the function
declaration and the function definition in C++, even if these are
ignored by the compiler in the declaration. Providing names for
function arguments is a part of the function documentation. The name
of an argument may clarify how the argument is used, reducing the need
to include comments in, for example, a class definition. It is also
easier to refer to an argument in the documentation of a class if it
has a name. 
<P>
<P><i>Exception to Rule 32:</i>   No exceptions!
<P>
<P><b>Example 38</b>   Declaration of formal arguments
<BR><pre>  int setPoint( int, int );   // No !
  int setPoint( int x, int y );   // Good
        
  int
  setPoint( int x, int y )
  {
    // ...
  }
        
</pre><P>
<a name="ReturnTypes"><h2>9.4  Return Types and Values</a></h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rule 33</b>  Always specify the return type of a function explicitly.
<P><b>Rule 34</b>  A public function must never return a reference or
a pointer to a local variable. 
<P>
Functions, for which no return type is explicitly declared, implicitly
receive int as the return type. This can be confusing for a beginner,
since the compiler gives a warning for a missing return type. Because
of this, functions which return no value should specify void as the
return type. 
<P>
If a function returns a reference or a pointer to a local variable,
the memory to which it refers will already have been deallocated, when
this reference or pointer is used. The compiler may or may not give a
warning for this. 
<P>
<P><i>Exception to Rule 33:</i>   No exceptions!
<P><i>Exception to Rule 34:</i>   No exceptions!
<P>
<P><b>Example 39</b>   Functions which return no value should be specified as having the return type void.
<BR><pre>  void
  strangeFunction( const char* before, const char* after )
  {
    // ...
  }
        
</pre><P>
<a name="InlineFunc"><h2>9.5  Inline Functions</a></h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rule 35</b>  Do not use the preprocessor directive #define to obtain more efficient code; instead,  use inline functions.
<P><b>Rec. 45</b>  Use inline functions when they are really needed.
<P>See also 7.2.
<P>Inline functions have the advantage of often being faster to
execute than ordinary functions. The disadvantage in their use is that
the implementation becomes more exposed, since the definition of an
inline function must be placed in an include file for the class, while
the definition of an ordinary function may be placed in its own
separate file. 
<P>
A result of this is that a change in the implementation of an inline
function can require comprehensive re-compiling when the include file
is changed. This is true for traditional file-based programming
environments which use such mechanisms as make for compilation. 
<P>
The compiler is not compelled to actually make a function inline. The
decision criteria for this differ from one compiler to another. It is
often possible to set a compiler flag so that the compiler gives a
warning each time it does not make a function inline (contrary to the
declaration). "Outlined inlines" can result in programs that are both
unnecessarily large and slow. 
<P>
It may be appropriate to separate inline definitions from class
definitions and to place these in a separate file. 
<P>
<P><i>Exception to Rule 35:</i>   No exceptions
<P>
<P><b>Example 40</b>   Inline functions are better than macros
<BR><pre>  // Example of problems with #define "functions"
  #define SQUARE(x) ((x)*(x))
  int a = 2;
  int b = SQUARE(a++);  // b = (2 * 3) = 6
        
  // Inline functions are safer and easier to use than macros if you
  // need an ordinary function that would have been unacceptable for
  // efficiency reasons.
  // They are also easier to convert to ordinary functions later on.
  inline int square( int x )
  {
    return ( x * x );
  };
        
  int c = 2;
  int d = square( c++ );   // d = ( 2 * 2 ) = 4
        
</pre><P>
<a name=TempObjects><h2>9.6  Temporary Objects</a></h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rec. 46</b>  Minimize the number of temporary objects that are
created as return values from functions or as arguments to functions. 
<P>
Temporary objects are often created when objects are returned from
functions or when objects are given as arguments to functions. In
either case, a constructor for the object is first invoked; later, a
destructor is invoked. Large temporary objects make for inefficient
code. In some cases, errors are introduced when temporary objects are
created. It is important to keep this in mind when writing code. It is
especially inappropriate to have pointers to temporary objects, since
the lifetime of a temporary object is undefined. (See 18.7). 
<P>
<P><b>Example 41</b>   Temporary objects and one way of eliminating them
<BR><pre>  class BigObject  { double big[123456]; };
        
  // Example of a very inefficient function with respect to temporary objects:
  BigObject
  slowTransform( BigObject myBO )
  {
    // When entering slowTransform(), myBO is a copy of the function argument
    // provided by the user. -> A copy constructor for BigObject is executed.
    // ... Transform myBO in some way
    return myBO;   // Transformed myBO returned to the user
  }
  // When exiting slowTransform(), a copy of myBO is returned to the
  // user -> copy-constructor for BigObject is executed, again.
        
  // Much more efficient solution:
  BigObject&amp;
  fastTransform( BigObject&amp; myBO )
  {
    // When entering fastTransform(), myBO is the same object as the function
    // argument provided by the user. -> No copy-constructor is executed.
        
    // Transform myBO in some way
    return myBO;   // Transformed myBO is returned to the user.
  }
  // When exiting fastTransform(), the very same myBO is returned 
  // to the user. -> No copy constructor executed.
        
  void main()
  {
    BigObject BO;
    BO = slowTransform( BO );
    BO = fastTransform( BO );   // Same syntax as slowTransform() !!
  }
        
</pre><P>
<a name="General"><h2>9.7  General</a></h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR><b>Rec. 47</b>  Avoid long and complex functions.
<P>Long functions have disadvantages:
<OL>
<LI> If a function is too long, it can be difficult to
comprehend. Generally, it can be said that a function should not be
longer than two pages, since that is about how much that can be
comprehended at one time. 
<LI>  If an error situation is discovered at the end of an extremely
long function, it may be difficult for the function to clean up after
itself and to "undo" as much as possible before reporting the error to
the calling function. By always using short functions, such an error
can be more exactly localized. 
</OL>
<P>
Complex functions are difficult to test. If a function consists of
15 nested if statements, then there are 2**15 (or 32768) different
branches to test in a single function. 
<P>
<a name="Constants"><h1>10  Constants</h1></a>
<a href="#BackToIndex">Back to index</a>
<P><b>Rule 36</b>  Constants are to be defined using const or enum;
never using #define. 
<P><b>Rule 37</b>  Avoid the use of numeric values in code; use
symbolic values instead. 
<P>The preprocessor performs a textual substitution for macros in the
source code which is then compiled. This has a number of negative
consequences. For example, if a constant has been defined using
#define, the name of the constant is not recognized in many
debuggers. If the constant is represented by an expression, this
expression may be evaluated differently for different instantiations,
depending on the scope of the name. In addition, macros are, at times,
incorrectly written. 
<P>
Numerical values in code ("Magic Numbers") should be viewed with
suspicion. They can be the cause of difficult problems if and when it
becomes necessary to change a value. A large amount of code can be
dependent on such a value never changing, the value can be used at a
number of places in the code (it may be difficult to locate all of
them), and values as such are rather anonymous (it may be that every
`2' in the code should not be changed to a `3'). 
<P>
From the point of view of portability, absolute values may be the
cause of more subtle problems. The type of a numeric value is
dependent on the implementation. Normally, the type of a numeric value
is defined as the smallest type which can contain the value.
<P>
<P><i>Exception to Rule 36:</i>   No exceptions.
<P><i>Exception to Rule 37:</i>   Certain numerical values have a well
established and clear meaning in a program. For example, '1' and '0'
are often used to represent `true' and `false' respectively. These may
be used directly in code without being considered to be "Magic". 
<P>
<P><b>Example 42</b>   Different ways of declaring constants.
<BR><pre>  // Constants using macros
  #define BUFSIZE 7       // No type checking
        
  // Constants using const
  const int bufSize = 7;       // Type checking takes place
        
  // Constants using enums
  enum SIZE { BufSize = 7 };   // Type checking takes place
        
</pre><P><b>Example 43</b>   Declaration of const defined in another file
<BR><pre>  extern const char constantCharacter;
  extern const String fileName;
        
</pre><P>
<a name="Variables"><h1>11  Variables</a></h1>

<a href="#BackToIndex">Back to index</a>

<P><b>Rule 38</b>  Variables are to be declared with the smallest possible scope.
<P><b>Rule 39</b>  Each variable is to be declared in a separate declaration statement.
<P><b>Rule 40</b>  Every variable that is declared is to be given a value before it is used.
<P><b>Rule 41</b>  If possible, always use initialization instead of assignment.
<P>
A variable ought to be declared with the smallest possible scope to
improve the readability of the code and so that variables are not
unnecessarily allocated. When a variable that is declared at the
beginning of a function is used somewhere in the code, it is not easy
to directly see the type of the variable. In addition, there is a risk
that such a variable is inadvertently hidden if a local variable,
having the same name, is declared in an internal block. 
<P>
Many local variables are only used in special cases which seldom
occur. If a variable is declared at the outer level, memory will be
allocated even if it is not used. In addition, when variables are
initialized upon declaration, more efficient code is obtained than if
values are assigned when the variable is used. 
<P>
A variable must always be initialized before use. Normally, the
compiler gives a warning if a variable is undefined. It is then
sufficient to take care of such cases. Instances of a class are
usually initialized even if no arguments are provided in the
declaration (the empty constructor is invoked). To declare a variable
that has been initialized in another file, the keyword extern is
always used. 
<P>
By always initializing variables, instead of assigning values to them
before they are first used, the code is made more efficient since no
temporary objects are created for the initialization. For objects
having large amounts of data, this can result in significantly faster
code. 
<P>
<P><i>Exception to Rule 38:</i>   No exceptions.
<P><i>Exception to Rule 39:</i>   No exceptions.
<P><i>Exception to Rule 40:</i>   No exceptions.
<P><i>Exception to Rule 41:</i>   In certain special cases, a variable
is assigned the value of a complicated expression; it may then be
unnecessary to give the variable an initial value. See Example 44. 
<P>
<P><b>Example 44</b>   Initialization instead of Assignment
<BR><pre>  //  Do not do this! 
  //  int i;
  //  ... 1022 lines of code
  //  i = 10;        
        
  int j = 10;                  // Better
        
  class Special                  //  Array of this class is used to initialize
  {                  // MyClass::complicated
    public:
      Special();         // Default constructor
      int isValid() const;
      int value() const;
  };
        
  const int Magic = 1066;
  Special specialInit[Magic];
        
  class MyClass
  {
    public:
      MyClass( const char* init );   // Constructor
      // ...
    private:
      String privateString;
      int complicated;
  };
        
  // Do not do this! Inefficient code.
  // Empty constructor + assignment operator called for privateString
  //
  // MyClass::MyClass( const char* init )
  // {
  //    privateString = init;   
  //    ...
  // }
        
  MyClass::MyClass( const char* init ) : privateString( init )  // Better
  {
    // Special case - complicated expression
        
    for( int i = 0; i&ltMagic; i++ )                        // No! You should enclose "for"
      if ( specialInit[i].isValid() )                     // loops in braces! See Rec. 25!
      {
        complicated = specialInit[i].value();                            
        break;
      }
  }
        
</pre><P>
<a name="Pointers_Ref"><h1>12  Pointers and References</a></h1>
<a href="#BackToIndex">Back to index</a>

<P><b>Rule 42</b>  Do not compare a pointer to NULL or assign NULL to a pointer; use 0 instead.
<P><b>Rec. 48</b>  Pointers to pointers should whenever possible be avoided.
<P><b>Rec. 49</b>  Use a typedef to simplify program syntax when declaring function pointers.
<P>According to the ANSI-C standard, NULL is defined either as
(void*)0 or as 0. If this definition remains in ANSI-C++, problems may
arise. If NULL is defined to have the type void*, it cannot be
assigned an arbitrary pointer without an explicit type conversion. For
this reason, we recommend comparisons with 0 at least until the
ANSI-C++ committee has made a decision. 
<P>
Pointers to pointers normally ought not be used. Instead, a class
should be declared, which has a member variable of the pointer
type. This improves the readability of the code and encourages data
abstraction. By improving the readability of code, the probability of
failure is reduced. One exception to this rule is represented by
functions which provide interfaces to other languages (such as
C). These are likely to only allow pre-defined data types to be used
as arguments in the interface, in which case pointers to pointers are
needed. Another example is the second argument to the main function,
which must have the type char*[]. 
<P>
A function which changes the value of a pointer that is provided as an
argument, should declare the argument as having the type reference to
pointer (e.g. char*&amp;). See Rec. 42! 
<P>
typedef is a good way of making code more easily maintainable and
portable. See chapter 18.1, Port.Rec.1. Another reason to use typedef
is that the readability of the code is improved. If pointers to
functions are used, the resulting code can be almost unreadable. By
making a type declaration for the function type, this is avoided. 
<P>
Function pointers can be used as ordinary functions; they do not need
to be dereferenced. 
<P>
<P><i>Exception to Rule 42:</i>   No exceptions.
<P>
<P><b>Example 45</b>   Different comparisons of pointers
<BR><pre>  char* sp = new char[100];
  if ( !sp )    cout &lt< "New failed!" &lt< endl;   // No!
  if ( sp == 0 )    cout &lt< "New failed!" &lt< endl;   // Best
  if ( sp == NULL ) cout &lt< "New failed!" &lt< endl;   // ERROR sometimes !!!
        
</pre><P><b>Example 46</b>   Pointers to pointers are often unnecessary
<BR><pre>  #include <iostream.h>
        
  void print_mij(int** m, int dim1, int dim2)
  {
    for (int i = 0; i&ltdim1; i++)
    {
      for (int j = 0; j&ltdim2; j++ )
        cout &lt< " " &lt< ((int*)m)[i*dim2+j];
      cout &lt< endl;
    }
  }
        
  // Could be written as:
        
  class Int_Matrix 
  { 
    public:
      Int_Matrix(int dim1, int dim2);
      int value(int,int) const;
      int dim1() const;
      int dim2() const;
    // ..
  };
        
  void print_Mij(Int_Matrix m)
  {
    for (int i = 0; i&ltm.dim1(); i++)
    {
      for (int j = 0; j&ltm.dim2(); j++ )
        cout &lt< " " &lt< m.value(i,j);
      cout &lt< endl;
    }
  }
        
</pre><P><b>Example 47</b>   Complicated declarations
<BR><pre>  // func1 is a function: int -> (function : const char* -> int)
  // i.e. a function having one argument of type int and returning
  // a pointer to a function having one argument of type const char* 
  // and returning an int.
        
  int (*func1(int))(const char*); 
        
  // func1 of the same type as func2
        
  typedef int FTYPE(const char*);
  FTYPE* func2(int);
        
  int (*(*func1p)(int))(const char*) = func2;
        
  // Realistic example from signal.h
        
  void (*signal(int,void (*)(int)))(int);
        
</pre><P><b>Example 48</b>   Syntax simplification of function pointers using a typedef
<BR><pre>  #include <math.h>
        
  // Ordinary messy way of declaring pointers to functions:
  // double ( *mathFunc ) ( double ) = sqrt;
        
  // With a typedef, life is filled with happiness (chinese proverb):
  typedef double MathFuncType( double );
  MathFuncType* mathFunc = sqrt;
        
  void 
  main()
  {
    // You can invoke the funktion in an easy or complicated way
    double returnValue1 = mathFunc( 23.0 );     // Easy way
    double returnValue2 = ( *mathFunc )( 23.0 ); // No! Correct, but complicated
  }
        
        
</pre><P>
<a name="Type_Conv"><h1>13  Type Conversions</a></h1>
<a href="#BackToIndex">Back to index</a>

<P><b>Rule 43</b>  Never use explicit type conversions (casts).
<P><b>Rule 44</b>  Do not write code which depends on functions that
use implicit type conversions. 
<P><b>Rule 45</b>  Never convert pointers to objects of a derived
class to pointers to objects of a virtual base class. 
<P><b>Rule 46</b>  Never convert a const to a non-const.
<P>
A type conversion may either be explicit or implicit, depending on
whether it is ordered by the programmer or by the compiler. Explicit
type conversions (casts) are used when a programmer want to get around
the compiler's typing system; for success in this endeavour, the
programmer must use them correctly. Problems which the compiler avoids
may arise, such as if the processor demands that data of a given type
be located at certain addresses or if data is truncated because a data
type does not have the same size as the original type on a given
platform. Explicit type conversions between objects of different types
lead, at best, to code that is difficult to read. 
<P>
Explicit type conversions (casts) can be motivated if a base class
pointer to a derived class pointer is needed. This happens when, for
example, a heterogeneous container class is used to implement a
container class to store pointers to derived class objects. This new
class can be made "type-safe" if the programmer excludes other objects
than derived class pointers from being stored. In order for this
implementation to work, it is necessary that the base class pointers
are converted to derived class pointers when they are removed from the
heterogeneous container class. 
<P>
The above reason for using explicit casts will hopefully disappear
when templates are introduced into C++. 
<P>
It is sometimes said that explicit casts are to object-oriented
programming, what the goto statement was to structured programming. 
<P>
There are two kinds of implicit type conversions: either there is a
conversion function from one type to another, written by the
programmer, or the compiler does it according to the language
standard. Both cases can lead to problems. 
<P>
C++ is lenient concerning the variables that may be used as arguments
to functions. If there is no function which exactly matches the types
of the arguments, the compiler attempts to convert types to find a
match. The disadvantage in this is that if more than one matching
function is found, a compilation error will be the result. Even worse
is that existing code which the compiler has allowed in other
contexts, may contain errors when a new implicit type conversion is
added to the code. Suddenly, there may be more than one matching
function. 
<P>
Another unpredictable effect of implicit type conversions is that
temporary objects are created during the conversion. This object is
then the argument to the function; not the original object. The
language definition forbids the assignment of temporary objects to
non-constant references, but most compilers still permit this. In most
cases, this can mean that the program does not work properly. Be
careful with constructors that use only one argument, since this
introduces a new type conversion which the compiler can unexpectedly
use when it seems reasonable in a given situation. 
<P>
Virtual base classes give rise to other type conversion problems. It
is possible to convert a pointer, to an instance of a class which has
a virtual base class, to a pointer to an object of that virtual base
class. The opposite conversion is not allowed, i.e. the type
conversion is not reversible. For this reason, we do not recommend the
conversion of a derived class pointer to a virtual base class
pointer. 
<P>
In order to return a non-const temporary object, it sometimes happens
that an explicit type conversion is used to convert const member data
to non-const. This is bad practice that should be avoided, primarily
because it should be possible for a compiler to allocate constants in
ROM (Read Only Memory). 
<P>
<P><i>Exception to Rule 43:</i>   An explicit type conversion (cast)
is preferable to a doubtful implicit type conversion. 
<P>
Explicit type conversions may be used to convert a pointer to a base
class to a pointer of a derived class within a type-safe container
class that is implemented using a heterogeneous container class. 
<P>
Explicit type conversion must be used to convert an anonymous
bit-stream to an object. This situation occurs when unpacking a
message in a message buffer. Generally, explicit type conversions are
needed for reading an external representation of an object. 
<P><i>Exception to Rule 44:</i>   At times it is desirable to have
constructors that use only one argument. By performing an explicit
type conversion, the correctness of the code does not depend on the
addition. See the Exception to Rule 22! 
<P><i>Exception to Rule 45:</i>   If a virtual base class is to
contain a pure virtual function which converts a virtual base class
pointer to a derived class pointer, this can be made to work by
defining the function in the derived class. Note that this implies
that all derived classes must be known in the virtual base class. See
Example 52! 
<P><i>Exception to Rule 46:</i>   No exceptions. Use pointers to data
allocated outside the class, when necessary. See Example 54 and
Example 55. 
<P>
<P><b>Example 49</b>   Constructors with a single argument that may
imply dangerous type conversions 
<BR><pre>  class String
  {
    public:
      String( int length );    // Allocation constructor
      // ...
  };
        
  // Function that receives an object of type String as an argument
  void foo( const String&amp; aString );
        
  // Here we call this function with an int as argument
  int x = 100;
  foo( x );  // Implicit conversion: foo( String( x ) );
        
</pre><P><b>Example 50</b>   A use of implicit type conversion
<BR><pre>  // String.hh
        
  class String
  {
    public:
      String( char* cp );    // Constructor
      operator const char* () const;  // Conversion operator to const char*
      // ...
  };
        
  void foo( const String&amp; aString );
  void bar( const char* someChars );
        
  // main.cc
        
  main()
  {
    foo( "hello" );        // Implicit type conversion char* -> String
    String peter = "pan";
    bar( peter );         // Implicit type conversion String -> const char*
  }
        
</pre><P><b>Example 51</b>   When implicit type conversion gives unpleasant results
<BR><pre>  // This function looks bulletproof, but it isn't.
  // Newer versions of compilers should flag this as an error.
  void
  mySwap( int&amp; x, int&amp; y )
  {
    int temp = x;
    x = y;
    y = temp;
  }
        
  int i = 10;
  unsigned int ui = 20;
  mySwap( i, ui );    // What really happens here is:
          // int T = int( ui );    // Implicit conversion
          // mySwap( i, T );       // ui is of course not changed!
          // Fortunately, the compiler warns for this !
            
</pre><P><b>Example 52</b>   Conversion of derived class pointer to a virtual base class pointer is irreversible
<BR><pre>  class VirtualBase 
  {
    public:
      virtual class Derived* asDerived() = 0;
  };
        
  class Derived : virtual public VirtualBase 
  {
    public:
      virtual Derived* asDerived();
  };
        
  Derived*
  Derived::asDerived()
  {
    return this;
  }
        
  void
  main()
  {
    Derived d;
    Derived* dp = 0;
    VirtualBase* vp = (VirtualBase*)&amp;d;
        
    dp = (Derived*)vp; // ERROR! Cast from virtual base class pointer
    dp = vp->asDerived(); // OK! Cast in function asDerived
  }
        
</pre><P><b>Example 53</b>   Addition which leads to a compile-time error
<BR><pre>  // String.hh
        
  class String
  {
    public:
      String( char* cp );     // Constructor
      operator const char* () const;   // Conversion operator to const char*
      // ...
  };
        
  void foo( const String&amp; aString );
  void bar( const char* someChars );
        
  // Word.hh
        
  class Word
  {
    public:
      Word( char* cp );   // Constructor
      // ...
  };
        
  // Function foo overloaded
        
  void foo( const Word&amp; aWord );
        
  // ERROR: foo( "hello" ) MATCHES BOTH:
  // void foo( const String&amp; );
  // AND void foo( const Word&amp; );
        
  //main.cc
        
  main()
  {
    foo( "hello" );        // Error ambiguous type conversion !
    String peter = "pan";
    bar( peter );         // Implicit type conversion String -> const char*
  }
        
</pre><P><b>Example 54</b>   For more efficient execution, remove
const-ness when storing intermediate results 
<BR><pre>  // This is code is NOT recommended
        
  #include <math.h>
        
  class Vector
  {
    public:
      Vector(int, const int []);  // Constructor
      double length() const;      // length = sqrt(array[1]*array[1] + ... )
      void set(int x, int value);
      // ...
    private:
      int size;
      int* array;
      double lengthCache;            // to cache calculated length
      int hasChanged;              // is it necessary to re-calculate length ?
  };
        
  double
  Vector::length() const
  {
    if (hasChanged) // Do we need to re-calculate length
    {
      ((Vector*)this)->hasChanged=0; // No! Cast away const
      double quadLength = 0;
      for ( int i = 0; i&ltsize; i++ )
      {
        quadLength += pow(array[i],2);
      }
      ((Vector*)this)->lengthCache = sqrt(quadLength); // No! Cast away const
    }
    return lengthCache;
  }
        
  void
  Vector::set( int nr, int value )
  {
    if ( nr >= size ) error( "Out Of Bounds");
    array[nr]=value;
    hasChanged = 1;
  }
        
</pre><P><b>Example 55</b>   Alternative to removing const-ness for more efficient execution
<BR><pre>        
  // This is code is safer than Example 54 but could be inefficient
        
  #include <math.h>
        
  class Vector
  {
    public:
      Vector(int, const int []);  // Constructor
      double length() const;      // length = sqrt(array[1]*array[1] + ... )
      void set(int x, int value);
      // ...
    private:
      int size;
      int* array;
      double* lengthCache;   // to cache length in
      int* hasChanged;       // is it necessary to re-calculate length ?
  };
        
  Vector::Vector(int sizeA, const int arrayA[])
  : size(sizeA), array( new int[sizeA] ),
    hasChanged(new int(1)), lengthCache(new double)
  {
    for ( int i = 0; i&ltsize; i++ )
    {
      array[i] = arrayA[i];
    }
  }
        
  Vector::~Vector()    // Destructor
  {
    delete array;
    delete hasChanged;
    delete lengthCache;
  }
        
  // Continue on next page !
  double
  Vector::length() const
  {
    if (hasChanged)     // Do we need to re-calculate length ?
    {
      *hasChanged=0;
      double quadLength = 0;
      for ( int i = 0; i&ltsize; i++ )
      {
        quadLength += pow(array[i],2);
      }
      *lengthCache = sqrt(quadLength);
    }
    return lengthCache;
  }
        
  void
  Vector::set( int nr, int value )
  {
    if ( nr >= size ) error( "Out Of Bounds");
    array[nr]=value;
    *hasChanged = 1;
  }
        
</pre><P>
<a name="Flow_Control"><h1>14  Flow Control Structures</h1></a>
<a href="#BackToIndex">Back to index</a>
<P><b>Rule 47</b>  The code following a case label must always be
terminated by a break statement. 
<P><b>Rule 48</b>  A switch statement must always contain a default
branch which handles unexpected cases. 
<P><b>Rule 49</b>  Never use goto.
<P><b>Rec. 50</b>  The choice of loop construct (for, while or
do-while) should depend on the specific use of the loop. 
<P><b>Rec. 51</b>  Always use unsigned for variables which cannot
reasonably have negative values. 
<P><b>Rec. 52</b>  Always use inclusive lower limits and exclusive upper limits.
<P><b>Rec. 53</b>  Avoid the use of continue.
<P><b>Rec. 54</b>  Use break to exit a loop if this avoids the use of flags.
<P><b>Rec. 55</b>  Do not write logical expressions of the type if(test) or if(!test) when test is a pointer.
<P>
Each loop construct has a specific usage. A for loop is used only when
the loop variable is increased by a constant amount for each iteration
and when the termination of the loop is determined by a constant
expression. In other cases, while or do-while should be used. When the
terminating condition can be evaluated at the beginning of the loop,
while should be used; do-while is used when the terminating condition
is best evaluated at the end of the loop. 
<P>
Goto breaks the control flow and can lead to code that is difficult to
comprehend. In addition, there are limitations for when goto can be
used. For example, it is not permitted to jump past a statement that
initializes a local object having a destructor. 
<P>
Variables representing size or length are typical candidates for
unsigned declarations. By following this recommendation some
unpleasant errors can be avoided. 
<P>
It is best to use inclusive lower and exclusive upper limits. Instead
of saying that x is in the interval x>=23 and x<=42, use the limits
x>=23 and x<43. The following important claims then apply:
<UL>
<LI> The size of the interval between the limits is the difference between the limits.
<LI>  The limits are equal if the interval is empty.
<LI>  The upper limit is never less than the lower limit.
</UL>
By being consistent in this regard, many difficult errors will be avoided.
<P>
If the code which follows a case label is not terminated by break, the
execution continues after the next case label. This means that poorly
tested code can be erroneous and still seem to work.  
<P>
continue can be used to exit from loops. However, code may be more
comprehensible by using an else clause instead. 
<P>
C++ has a very loose and, simultaneously, very free way of determining
if an expression is true or false. If an expression is evaluated as 0,
it is false; otherwise, it is considered to be true. 
<P>
We do not recommend logical tests such as "if(pointer)" if "pointer"
is a variable of pointer-type. The only reason is readablity; many
programmers find it difficult to read such code.  
<P>
Consider the scope within which an iteration variable is visible. A
variable that is declared within a `for' statement is currently only
visible in the nearest enclosing block. The standardization committee
for C++ is however discussing a language modification regarding this
point. No decision has yet been made. Still, this problem is avoided
if the control structure is encapsulated in a compound statement.  
<P>
<P><i>Exception to Rule 47:</i>   When several case labels are
followed by the same block of code, only one break statement is
needed. Also, other statements than break may be used to exit a switch
statement, such as return. 
<P><i>Exception to Rule 48:</i>   No exceptions.
<P><i>Exception to Rule 49:</i>   For extremely time-critical
applications or for fault handling, goto may be permitted. Every such
usage must be carefully motivated. 
<P>        
<P><b>Example 56</b>   Problem using unsigned loop variables
<BR><pre>  for( unsigned int i = 3; i >= 0; --i )
  {
    // This loop will never terminate, since i cycles through:
    // 3, 2, 1, 0, 4294967295, 4294967294, etc ... on a SparcStation
    // Note that this example does not follow the rules: i >= 0
    // in the for statement. See next example !
  }
        
</pre><P><b>Example 57</b>   Visibility of variable declared in `for' loop
<BR><pre>  for ( int index = 0; index&lt10; index++ )
  {
    cout &lt< index;
  }
        
  int index = 3;   // ERROR, THIS IS AN ILLEGAL RE-DECLARATION OF index
       // BECAUSE index IS DECLARED IN BLOCK-SCOPE.
       
</pre><P><b>Example 58</b>   Dangerous switch/case statement
<BR><pre>  switch ( tag )
  {
    case A:
    {
      // Do something
      // Next statement is a call to foo() inside next case
    }
        
    case B:
    {
      foo();
      // Do something else
      break;      // Now we leave the switch-statement
    }
        
    default:
    {
      // If no match in above cases, this is executed
      exit( 1 );
    }
  }
        
</pre><P><b>Example 59</b>   Good and bad ways of setting limits for loop variables
<BR><pre>  int a[10];
  int ten = 10;
  int nine = 9;
        
  // Good way to do it:
  for( int i = 0; i&ltten; i++ )       // Loop runs 10-0=10 times
  {
    a[i] = 0;
  }
   
  // Bad way to do it:
  for( int j = 0; j <= nine; j++ )     // Loop runs 10 times, but 9-0=9 !!!
  {
    a[j] = 0;
  }
        
</pre><P><b>Example 60</b>   Using break to exit a loop, no flags are needed.
<BR><pre>  do             // This way:
  {
    if ( Something )
    {
      // Do something
      break;
    }
  } while( someCondition );
        
        
  int endFlag = 0;         // Is better than this:
  do
  {
    if ( /* Something */ )
    {
      // Do something
      endFlag = 1;
    }
  } while( someCondition &amp;&amp; !endFlag );
        
</pre><P><b>Example 61</b>   By using an extra `else' clause,  continue is avoided and the code can be comprehended.
<BR><pre>  while( /* Something */ )       // This way is more clear
  {
    if( /* Something */ )
    {
      // Do something
    }
        
    else
    {
      // Do something else
    }
  }
        
        
  while( /* Something */ )       // Than using continue
  {
    if( /* Something */ )
    {
      // Do something
      continue;          // No !
    }
    // Do something else
  }
        
</pre><P>
<a name="Expressions"><h1>15  Expressions</h1></a>
<a href="#BackToIndex">Back to index</a>
<P><b>Rec. 56</b>  Use parentheses to clarify the order of evaluation for operators in expressions.
<P>
There are a number of common pitfalls having to do with the order of
evaluation for operators in an expression. Binary operators in C++
have associativity (either leftwards or rightwards) and precedence. If
an operator has leftwards associativity and occurs on both sides of a
variable in an expression, then the variable belongs to the same part
of the expression as the operator on its left side. 
<P>
In doubtful cases, parentheses always are to be used to clarify the
order of evaluation. 
<P>
Another common mistake is to confuse the assignment operator and the
equality operator. Since the assignment operator returns a value, it
is entirely permitted to have an assignment statement instead of a
comparison expression. This, however, most often leads straight to an
error. 
<P>
C++ allows the overloading of operators, something which can easily
become confusing. For example, the operators &lt< (shift left) and
&gt>(shift right) are often used for input and output. Since these
were originally bit operations, it is necessary that they have higher
priority than relational operators. This means that parentheses must
be used when outputting the values of logical expressions. 
<P>
<P><b>Example 62</b>   Problem with the order of evaluation
<BR><pre>  // Interpreted as ( a&ltb )&ltc, not ( a&ltb ) &amp;&amp; ( b&ltac )
  if ( a&ltb&ltc )
  {
    // ...
  }
        
  // Interpreted as a &amp; ( b&lt8 ), not ( a &amp; b )&lt8
  if ( a &amp; b&lt8 )
  {
    // ...
  }
        
</pre>
<P><b>Example 63</b>   When parentheses are recommended
<BR><pre>  int i = a >= b &amp;&amp; c&ltd &amp;&amp; e + f &lt = g + h;           // No!
  int j = ( a >= b ) &amp;&amp; ( c&ltd ) &amp;&amp; (( e + f ) &lt = ( g + h ));   // Better
        
</pre>
<a name="MemAlloc"><P><h1>16  Memory Allocation</h1></a>
<a href="#BackToIndex">Back to index</a>
<P><b>Rule 50</b>  Do not use malloc, realloc or free.
<P><b>Rule 51</b>  Always provide empty brackets ("[]") for delete
when deallocating arrays. 
<P><b>Rec. 57</b>  Avoid global data if at all possible.
<P><b>Rec. 58</b>  Do not allocate memory and expect that someone else
will deallocate it later. 
<P><b>Rec. 59</b>  Always assign a new value to a pointer that points
to deallocated memory. 
<P>
In C++ data can be allocated statically, dynamically on the stack,
or dynamically on the heap. There are three categories of static data:
global data, global class data, and static data local to a function. 
<P>
In C malloc, realloc and free are used to allocate memory dynamically
on the heap. This may lead to conflicts with the use of the new and
delete operators in C++. 
<P>It is dangerous to:
<OL>
<LI> invoke delete for a pointer obtained via malloc/realloc,
<LI> invoke malloc/realloc for objects having constructors,
<LI> invoke free for anything allocated using new.
</OL>
Thus, avoid whenever possible the use of malloc, realloc and free.
<P>
If an array a having a type T is allocated, it is important to invoke
delete in the correct way. Only writing delete a; will result in the
destructor being invoked only for the first object of type T. By
writing delete [m] a; where m is an integer which is greater than the
number of objects allocated earlier, the destructor for T will be
invoked for memory that does not represent objects of type T. The
easiest way to do this correctly is to write delete [] a; since the
destructor will then be invoked only for those objects which have been
allocated earlier. 
<P>
Static data can cause several problems. In an environment where
parallel threads execute simultaneously, they can make the behaviour
of code unpredictable, since functions having static data are not
reentrant. 
<P>
One difference between ANSI-C and C++ is in how constants are
declared. If a variable is declared as a constant in ANSI-C, it has
the storage class extern (global). In C++, however, it normally has
the storage class static (local). The latter means that a new instance
of the constant object is created each time a file includes the file
which contains the declaration of the object, unless the variable is
explicitly declared extern in the include file. 
<P>
An extern declaration in C++ does not mean that the variable is
initialized; there must be a definition for this in a definition
file. Static constants that are defined within a class are always
external and must always be defined separately. 
<P>
It may, at times, be tempting to allocate memory for an object using
new, expecting someone else to deallocate the memory. For instance, a
function can allocate memory for an object which is then returned to
the user as the return value for the function. There is no guarantee
that the user will remember to deallocate the memory and the interface
with the function then becomes considerably more complex. 
<P>
Pointers that point to deallocated memory should either be set to 0 or
be given a new value to prevent access to the released memory. This
can be a very difficult problem to solve when there are several
pointers which point to the same memory, since C++ has no garbage
collection. 
<P>
<P><i>Exception to Rule 50:</i>   No exceptions.
<P><i>Exception to Rule 51:</i>   No exceptions.
<P>
<P><b>Example 64</b>   Right and wrong ways to invoke delete for arrays with destructors
<BR><pre>  int n = 7;
  T* myT = new T[n]; // T is a type with defined constructors and destructors
  // ...
  delete myT;      // No! Destructor only called for first object in array a
  delete [10] myT;     // No! Destructor called on memory out of bounds in array a
  delete [] myT;     // OK, and always safe!
        
</pre><P><b>Example 65</b>   Dangerous memory management
<BR><pre>  String myFunc( const char* myArgument )
  {
    String* temp = new String( myArgument );
    return *temp;
    // temp is never deallocated and the user of myFunc cannot deallocate
    // because a temporary copy of that instance is returned.
  }
        
</pre>
<a name="FaultHandling"><P><h2>17  Fault Handling</h2></a>
<a href="#BackToIndex">Back to index</a>
<P><b>Rec. 60</b>  Make sure that fault handling is done so that the
transfer to exception handling (when this is available in C++) may be
easily made. 
<P><b>Rec. 61</b>  Check the fault codes which may be received from
library functions even if these functions seem foolproof. 
<P>
In November 1990, the ANSI C++ committee accepted a proposal for
exception handling which is described in chapter 15 of ref. 1. When
designing fault handling in code, it is appropriate to consider being
able to make a smooth transfer to exception handling. For example,
instead of using ordinary fault codes, which may necessitate a lot of
re-programming when exception handling is available, a call can be
made to a function void fault(const char*)which sends a fault message
(somewhere) and then terminates execution in some way. 
<P>
System functions (those which are specific to UNIX) ought to be used
with care if the code is to be portable. If such functions are used,
the possible fault codes that may be received should be carefully
checked. 
<P>
Two important characteristics of a robust system are that all faults
are reported and, if the fault is so serious that continued execution
is not possible, the process is terminated. In this way, the
propagation of faults through the system is avoided. It is better to
have a process crash, than to spread erroneous information to other
processes. In achieving this goal, it is important to always test
fault codes from library functions. The opening or closing of files
may fail, allocation of data may fail, etc. One test too many is
better than one test too few. Our own functions should preferably not
return fault codes, but should instead take advantage of exception
handling. 
<P>
<P><b>Example 66</b>   Future exception handling in C++
<BR><pre>  // The top function where we catch exceptions thrown in called functions
  int f()
  {
    // We suspect that something can go wrong when function g() is called.
    // Therefore, we enclose the call in a try block.
    try
    {
      return g();    // This is the try block
    }
        
    // If any exceptions, having a given type, were thrown when g()
    // was executing, they are caught in these two catch blocks.
    catch ( int x )      // catches int
    {
      cerr &lt< "Number " &lt< x &lt< " happened !" &lt< endl;
      return x;
    }
        
    catch ( char* x )    // catches char*
    {
      // Respond in some other way
    }
        
    // Anything else that is thrown, is thrown up to the function that calls f()
  }
        
  // This function has no try or catch block. When the exception is thrown
  // in function h(), it is thrown up to the function f().
  int g()
  {
    return h();
  }
        
  extern int somethingIsVeryWrongAndICannotHandleThisAnyMore();
        
  int h()
  {
    // Here we find out that something went wrong, and throw an exception
    if (somethingIsVeryWrongAndICannotHandleThisAnyMore())
    {
      // In this case, we throw an int as exception, but almost any object
      // can be thrown. See Errata for "The Annotated C++ Reference Manual"
      // section 15.7.
      throw 2;
    }
        
    // Keep on trucking if all is OK
  }
        
</pre>
<a name="PortableCode"><P><h1>18  Portable Code</h1></a>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR>
<a name="DataAbstract"><P><h2>18.1  Data Abstraction</a></h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR>Port. Rec. 1  Avoid the direct use of pre-defined data types in declarations.
<P>An excellent way of transforming your world to a "vale of tears" is
to directly use the pre-defined data types in declarations. If it is
later necessary, due to portability problems, to change the return
type of a function, it may be necessary to make change at a large
number of places in the code. One way to avoid this is to declare a
new type name using classes or typedefs to represent the types of
variables used. In this way, changes can be more easily made. This may
be used to give data a physical unit, such as kilogram or meter. Such
code is more easily reviewed. (For example, when the code is
functioning poorly, it may be noticed that a variable representing
meters has been assigned to a variable representing kilograms). It
should be noted that a typedef does not create a new type, only an
alternative name for a type. This means that if you have declared
typedef int Error, a variable of the type Error may be used anywhere
that an int may be used. 
<P>See also chapter 12, Rec. 49!
<BR>
<P><b>Example 67</b>   Type declarations using typedef
<BR><pre>  // Instead of:
  long int time;
  short int mouseX;
  char* menuName;
        
  // Use (for example):
  typedef long int TimeStamp;
  typedef short int Coordinate;
  class String { /* ... */ };
        
  // and:
  TimeStamp time;
  Coordinate mouseX;
  String menuName;
        
</pre>
<a name="TypeSizes"><P><h2>18.2  Sizes of Types</a></h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR>
Port. Rec. 2  Do not assume that an int and a long have the same size.
<BR>Port. Rec. 3  Do not assume that an int is 32 bits long (it may be only 16 bits long).
<P>Port. Rec. 4  Do not assume that a char is signed or unsigned.
<BR>Port. Rec. 5  Always set char to unsigned if 8-bit ASCII is used.
<P>
In the definition of the C++ language, it has not yet been decided if
a char is signed or unsigned. This decision has instead been left to
each compiler manufacturer. If this is forgotten and this
characteristic is exploited in one way or another, some difficult bugs
may appear in the program when another compiler is used. 
<P>
If 8-bit ASCII is used (as is quite likely in the future) and
comparisons are made of two characters, it is important that unsigned
char is used. 
<P>
<a name="ConvTypes"><P><h2>18.3  Type Conversions</a></h2>
<a href="#BackToIndex">Back to index</a>
<P>Port. Rec. 6  Be careful not to make type conversions from a "shorter" type to a "longer" one.
<P>Port. Rec. 7  Do not assume that pointers and integers have the
same size. 
<P>Port. Rec. 8  Use explicit type conversions for arithmetic using signed and unsigned values.
<P>
A processor architecture often forbids data of a given size to be
allocated at an arbitrary address. For example, a word must begin on
an "even" address for MC680x0. If there is a pointer to a char which
is located at an "odd" address, a type conversion from this char
pointer to an int pointer will cause the program to crash when the int
pointer is used, since this violates the processor's rules for
alignment of data. 
<P>
<a name="DataRep"><P><h2>18.4  Data Representation</a></h2>
<a href="#BackToIndex">Back to index</a>
<P>Port. Rec. 9  Do not assume that you know how an instance of a data type is represented in memory.
<P>Port. Rec. 10  Do not assume that longs, floats, doubles or long doubles may begin at arbitrary addresses.
<P>
The representation of data types in memory is highly
machine-dependent. By allocating data members to certain addresses, a
processor may execute code more efficiently. Because of this, the data
structure that represents a class will sometime include holes and be
stored differently in different process architectures. Code which
depends on a specific representation is, of course, not portable. 
<P>See18.3 for explanation of Port. Rec. 10.
<BR>
<BR>
<a name="UnderFlow"><P><h2>18.5  Underflow/Overflow</a></h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR>
Port. Rec. 11  Do not depend on underflow or overflow functioning in any special way.
<P>
<a name="ExecOrder"><h2>18.6  Order of Execution</a></h2>
<a href="#BackToIndex">Back to index</a>
<P>Port. Rec. 12  Do not assume that the operands in an expression are
evaluated in a definite order. 
<P>Port. Rec. 13  Do not assume that you know how the invocation
mechanism for a function is implemented. 
<P>Port. Rec. 14  Do not assume that an object is initialized in any
special order in constructors. 
<P>Port. Rec. 15  Do not assume that static objects are initialized in
any special order. 
<P>If a value is modified twice in the same expression, the result of
the expression is undefined except when the order of evaluation is
guaranteed for the operators that are used. 
<P>
The order of initialization for static objects may present problems. A
static object may not be used in a constructor, if it is not
initialized until after the constructor is run. At present, the order
of initialization for static objects, which are defined in different
compilation units, is not defined. This can lead to errors that are
difficult to locate (see Example 69). There are special techniques for
avoiding this. See Example 29! 
<P>
<P><b>Example 68</b>   Do not depend on the order of initialization in constructors.
<BR><pre>  #include <iostream.h>
  class X
  {
    public:
      X(int y);
    private:
      int i;
      int j;
  };
        
  inline X::X(int y) : j(y), i(j)    // No! j may not be initialized before i !!
  {
    cout &lt< "i:" &lt< i &lt< " &amp; " &lt< "j:" &lt< j /lt< endl;
  }
        
  main()
  {
    X x(7);        // Rather unexpected output: i:0 &amp; j:7
  }
        
</pre><P><b>Example 69</b>   Initialization of static objects
<BR><pre>  // Foo.hh
        
  #include <iostream.h>
  #include <string.h>
        
  static unsigned int const Size = 1024;
        
  class Foo 
  {
    public:
      Foo( char* cp );     // Constructor
      // ...
    private:
      char buffer[Size];
      static unsigned counter;  // Number of constructed Foo:s
  };
        
  extern Foo foo_1;
  extern Foo foo_2;
        
  // Foo1.cc
  #include "Foo.hh"
        
  unsigned Foo::counter = 0;
  Foo foo_1 = "one";
        
  //Foo2.cc
  #include "Foo.hh"
        
  Foo foo_2 = "two";
        
  Foo::Foo( char* cp )    // Irrational constructor
  {
    strncpy( buffer, cp, sizeof(buffer) );
    foos[counter] = this;
    switch ( counter++ )
    {
      case 0:
      case 1:    
        cout &lt< ::foo_1.buffer &lt< "," &lt< ::foo_2.buffer &lt< endl;
        break;
      default:
        cout &lt< "Hello, world" &lt< endl;
    }      
  }
  // If a program using Foo.hh is linked with Foo1.o and Foo2.o, either 
  // ,two      or  one,    is written on standard output depending on
  // one,two   one,two  the order of the files given to the linker.
        
</pre>
<a name="Objemp"><P><h2>18.7  Temporary Objects</a></h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR>
Port. Rec. 16  Do not write code which is dependent on the lifetime of a temporary object.
<P>
Temporary objects are often created in C++, such as when functions
return a value. Difficult errors may arise when there are pointers in
temporary objects. Since the language does not define the life
expectancy of temporary objects, it is never certain that pointers to
them are valid when they are used. 
<P>
One way of avoiding this problem is to make sure that temporary
objects are not created. This method, however, is limited by the
expressive power of the language and is not generally recommended. 
<P>
The C++ standard may someday provide an solution to this problem. In
any case, it is a subject for lively discussions in the
standardization committee. 
<P>
<P><b>Example 70</b>   Difficult error in a string class which lacks output operator
<BR><pre>  class String
  {
    public:
      operator const char*() const;    // Conversion operator to const char*
      friend String operator+( const String&amp; left, const String&amp; right );
      // ...
  };
        
  String a = "This may go to ";
  String b = "h***!";
    // The addition of a and b generates a new temporary String object.
    // After it is converted to a char* by the conversion operator, it is
    // no longer needed and may be deallocated. This means that characters
    // which are already deallocated are printed to cout -> DANGEROUS!!
  cout &lt< a + b;
        
</pre><P>
<a name="PointAri"><h2>18.8  Pointer Arithmetic</a></h2>
<a href="#BackToIndex">Back to index</a>
<BR>
<BR>
Port. Rec. 17  Avoid using shift operations instead of arithmetic operations.
<BR>Port. Rec. 18  Avoid pointer arithmetic.
<P>
Pointer arithmetic can be portable. The operators == and != are
defined for all pointers of the same type, while the use of the
operators <, >, <=, >= are portable only if they are used between
pointers which point into the same array. 
<P>
<a name="Refs"><h1>19  References</h1></a>
<a href="#BackToIndex">Back to index</a>
<OL>
<LI>  The Annotated C++ Reference Manual - Bjarne Stroustrup/Margareth Ellis[ARM]
<BR>  - Addison Wesley 1990, ISBN 0-201-51459-1
<BR>This book forms the basis of the work in the ANSI-C++ committee.
<LI>  C++ Primer, Second Edition - Stanley B. Lippman
<BR>  - Addison Wesley 1991, ISBN 0-201-54848-8
<BR>Very good for learning the basics of C++.
<LI>  The C++ Programming Language, Second Edition - Bjarne Stroustrup
<BR>  - Addison Wesley 1991, ISBN 0-201-53992-6
<BR>This second edition has been completely updated with the current (and future) language definition. It will most certainly become a standard reference book.
<LI>  Advanced C++ Programming Styles and Idioms - James O. Coplien
<BR>  - Addison Wesley 1992, ISBN 0-210-54855-0
<BR>Possibly the most advanced book on how to use C++. Contains many tricks and tips.
<LI>  Object-oriented Software Construction - Bertrand Meyer
<BR>  - Prentice Hall 1988, ISBN 0-13-629049-3 or 0-13-629031-0 PBK
<BR>Somewhat of a classic work. Examples are written in Eiffel.
<LI>  Data Abstraction and Object-Oriented Programming in C++ - Keith E. Gorlen, Sanford M. Orlow, Perry S. Plexico
<BR>  - John Wiley &amp; Sons 1990, ISBN 0 471 92346 X pbk or 0 471 92751 1
<BR>The book that describes the class library NIH. Includes many good examples.
<LI>  Object-Oriented Design with Applications - Grady Booch
<BR>  - Benjamin/Cummings 1991, ISBN 0-8053-0091-0
<BR>Treats the design and implementation of software in various object-oriented languages.
<LI>  Recommended C Style and Coding Standards
<BR>  - Bell Labs, Zoology Computer Systems University of Toronto, CS University of Washington, November 18, 1989.
<BR>A collection of rules for programming in C. Contains a good
section on portability. 
<LI>  A Guide to Natural Naming - Daniel Keller
<BR>  - ETH, Projekt-Zentrum IDA, CH-8092 Zurich, Switzerland
<BR>A guide on how to choose good names for functions and variables. Not adapted to object-oriented programming.
<LI>  Advanced C++ - Jonathan E. Shopiro
<BR>Binder with material from course held in Lund (Sweden) from June 4 to June 7, 1991. Filled with warnings and tips.
<LI>  Objektorienterad programmering och biblioteksuppbyggnad i C++ - Martin Carrol
<BR>Material from course held in Stockholm (Sweden) on April 18, 1991. Presents useful viewpoints on problems which may arise when designing a class library.
<LI>  Automatic Detection of C++ Programming Errors: Initial Thoughts on a lint++ - Scott Myers/Moises Lejter
<BR>  - Usenix C++ Conference Proceedings, Spring 91
<BR>Article which describes some programming rules for C++.
<LI>  Code-Style Prescriptions - Carl R. Dickler
<BR>  - Unix Review, 9(9), 1991, pages 41-45
<BR>Article which describes a number of programming rules for C and
which discusses why programming rules are needed.
</OL>
<P>
<a name="RuleSummary"><h1>20  Summary of Rules</h1></a>
<a href="#BackToIndex">Back to index</a>
<P><b>Rule 0</b>   Every time a rule is broken, this must be clearly documented.
<P><b>Rule 1</b>   Include files in C++ always have the file name extension ".hh".
<P><b>Rule 2</b>   Implementation files in C++ always have the file name extension ".cc".
<P><b>Rule 3</b>   Inline definition files always have the file name extension ".icc".
<P><b>Rule 4</b>   Every file that contains source code must be documented with an introductory comment that provides information on the file name and its contents.
<P><b>Rule 5</b>   All files must include copyright information.
<P><b>Rule 6</b>   All comments are to be written in English.
<P><b>Rule 7</b>   Every include file must contain a mechanism that prevents multiple inclusions of the file.
<P><b>Rule 8</b>   When the following kinds of definitions are used (in implementation files or in other include files), they must be included as separate include files:
<P>·  classes that are used as base classes,
<BR>·  classes that are used as member variables,
<BR>·  classes that appear as return types or as argument types in function/member function prototypes.
<P>·  function prototypes for functions/member functions used in inline member functions  that are defined in the file.
<P><b>Rule 9</b>   Definitions of classes that are only accessed via pointers (*) or references (&amp;) shall not be included as include files.
<P><b>Rule 10</b>   Never specify relative UNIX names in #include directives.
<P><b>Rule 11</b>   Every implementation file is to include the relevant files that contain:
<P>·  declarations of types and functions used in the functions that are implemented in the file.
<P>·  declarations of variables and member functions used in the functions that are implemented in the file.
<P><b>Rule 12</b>   The identifier of every globally visible class, enumeration type, type definition, function, constant, and variable in a class library is to begin with a prefix that is unique for the library.
<P><b>Rule 13</b>   The names of variables, constants, and functions are to begin with a lowercase letter.
<P><b>Rule 14</b>   The names of abstract data types, structures, typedefs, and enumerated types are to begin with an uppercase letter.
<P><b>Rule 15</b>   In names which consist of more than one word, the words are written together and each word that follows the first is begun with an uppercase letter.
<P><b>Rule 16</b>   Do not use identifiers which begin with one or two underscores (`_' or `__').
<P><b>Rule 17</b>   A name that begins with an uppercase letter is to appear directly after its prefix.
<P><b>Rule 18</b>   A name that begins with a lowercase letter is to be separated from its prefix using an underscore (`_').
<P><b>Rule 19</b>   A name is to be separated from its suffix using an underscore (`_').
<P><b>Rule 20</b>   The public, protected, and private sections of a class are to be declared in that order (the public section is declared before the protected section which is declared before the private section).
<P><b>Rule 21</b>   No member functions are to be defined within the class definition.
<P><b>Rule 22</b>   Never specify public or protected member data in a class.
<P><b>Rule 23</b>   A member function that does not affect the state of an object (its instance variables) is to be declared const.
<P><b>Rule 24</b>   If the behaviour of an object is dependent on data outside the object, this data is not to be modified by const member functions.
<P><b>Rule 25</b>   A class which uses "new" to allocate instances managed by the class,  must define a copy constructor.
<P><b>Rule 26</b>   All classes which are used as base classes and which have virtual functions, must define a virtual destructor.
<P><b>Rule 27</b>   A class which uses "new" to allocate instances managed by the class,  must define an assignment operator.
<P><b>Rule 28</b>   An assignment operator which performs a destructive action must be protected from performing this action on the object upon which it is operating.
<P><b>Rule 29</b>   A public member function must never return a non-const reference or pointer to member data.
<P><b>Rule 30</b>   A public member function must never return a non-const reference or pointer to data outside an object, unless the object shares the data with other objects.
<P><b>Rule 31</b>   Do not use unspecified function arguments (ellipsis notation).
<P><b>Rule 32</b>   The names of formal arguments to functions are to be specified and are to be the same both in the function declaration and in the function definition.
<P><b>Rule 33</b>   Always specify the return type of a function explicitly.
<P><b>Rule 34</b>   A public function must never return a reference or a pointer to a local variable.
<P><b>Rule 35</b>   Do not use the preprocessor directive #define to obtain more efficient code; instead,  use inline functions.
<P><b>Rule 36</b>   Constants are to be defined using const or enum; never using #define.
<P><b>Rule 37</b>   Avoid the use of numeric values in code; use symbolic values instead.
<P><b>Rule 38</b>   Variables are to be declared with the smallest possible scope.
<P><b>Rule 39</b>   Each variable is to be declared in a separate declaration statement.
<P><b>Rule 40</b>   Every variable that is declared is to be given a value before it is used.
<P><b>Rule 41</b>   If possible, always use initialization instead of assignment.
<P><b>Rule 42</b>   Do not compare a pointer to NULL or assign NULL to a pointer; use 0 instead.
<P><b>Rule 43</b>   Never use explicit type conversions (casts).
<P><b>Rule 44</b>   Do not write code which depends on functions that use implicit type conversions.
<P><b>Rule 45</b>   Never convert pointers to objects of a derived class to pointers to objects of a virtual base class.
<P><b>Rule 46</b>   Never convert a const to a non-const.
<P><b>Rule 47</b>   The code following a case label must always be terminated by a break statement.
<P><b>Rule 48</b>   A switch statement must always contain a default branch which handles unexpected cases.
<P><b>Rule 49</b>   Never use goto.
<P><b>Rule 50</b>   Do not use malloc, realloc or free.
<P><b>Rule 51</b>   Always provide empty brackets ("[]") for delete when deallocating arrays.
<P>
<a name="RecommendSum"><h1>21  Summary of Recommendations</h1></a>
<a href="#BackToIndex">Back to index</a>
<P><b>Rec. 1</b>   Optimize code only if you know that you have a performance problem. Think twice before you begin.
<P><b>Rec. 2</b>   If you use a C++ compiler that is based on Cfront, always compile with the +w flag set to eliminate as many warnings as possible.
<P><b>Rec. 3</b>   An include file should not contain more than one class definition.
<P><b>Rec. 4</b>   Divide up the definitions of member functions or functions into as many files as possible.
<P><b>Rec. 5</b>   Place machine-dependent code in a special file so that it may be easily located when porting code from one machine to another.
<P><b>Rec. 6</b>   Always give a file a name that is unique in as large a context as possible.
<P><b>Rec. 7</b>   An include file for a class should have a file name of the form <class name> + extension. Use uppercase and lowercase letters in the same way as in the source code.
<P><b>Rec. 8</b>   Write some descriptive comments before every function.
<P><b>Rec. 9</b>   Use // for comments.
<P><b>Rec. 10</b>   Use the directive #include "filename.hh" for user-prepared include files.
<P><b>Rec. 11</b>   Use the directive #include <filename.hh> for include files from libraries.
<P><b>Rec. 12</b>   Every implementation file should declare a local constant string that describes the file so the UNIX command what can be used to obtain information on the file revision.
<P><b>Rec. 13</b>   Never include other files in an ".icc" file.
<P><b>Rec. 14</b>   Do not use typenames that differ only by the use of uppercase and lowercase letters.
<P><b>Rec. 15</b>   Names should not include abbreviations that are not generally accepted.
<P><b>Rec. 16</b>   A variable with a large scope should have a long name.
<P><b>Rec. 17</b>   Choose variable names that suggest the usage.
<P><b>Rec. 18</b>   Write code in a way that makes it easy to change the prefix for global identifiers.
<P><b>Rec. 19</b>   Encapsulate global variables and constants, enumerated types, and typedefs in a class.
<P><b>Rec. 20</b>   Always provide the return type of a function explicitly.
<P><b>Rec. 21</b>   When declaring functions, the leading parenthesis and the first argument (if any) are to be written on the same line as the function name. If space permits, other arguments and the closing parenthesis may also be written on the same line as the function name. Otherwise, each additional argument is to be written on a separate line (with the closing parenthesis directly after the last argument).
<P><b>Rec. 22</b>   In a function definition, the return type of the function should be written on a separate line directly above the function name.
<P><b>Rec. 23</b>   Always write the left parenthesis directly after a function name.
<P><b>Rec. 24</b>   Braces ("{}") which enclose a block are to be placed in the same column, on separate lines directly before and after the block.
<P><b>Rec. 25</b>   The flow control primitives if, else, while, for and do should be followed by a  block, even if it is an empty block.
<P><b>Rec. 26</b>   The dereference operator `*' and the address-of operator `&amp;' should be directly connected with the type names in declarations and definitions.
<P><b>Rec. 27</b>   Do not use spaces around `.' or `->', nor between unary operators and operands.
<P><b>Rec. 28</b>   Use the c++ mode in GNU Emacs to format code.
<P><b>Rec. 29</b>   Access functions are to be inline.
<P><b>Rec. 30</b>   Forwarding functions are to be inline.
<P><b>Rec. 31</b>   Constructors and destructors must not be inline.
<P><b>Rec. 32</b>   Friends of a class should be used to provide additional functions that are best kept outside of the class.
<P><b>Rec. 33</b>   Avoid the use of global objects in constructors and destructors.
<P><b>Rec. 34</b>   An assignment operator ought to return a const reference to the assigning object.
<P><b>Rec. 35</b>   Use operator overloading sparingly and in a uniform manner.
<P><b>Rec. 36</b>   When two operators are opposites (such as == and !=), it is appropriate to define both.
<P><b>Rec. 37</b>   Avoid inheritance for parts-of relations.
<P><b>Rec. 38</b>   Give derived classes access to class type member data by declaring protected access functions.
<P><b>Rec. 39</b>   Do not attempt to create an instance of a class template using a type that does not define the member functions which the class template, according to its documentation,  requires.
<P><b>Rec. 40</b>   Take care to avoid multiple definition of overloaded functions in conjunction with the instantiation of a class template.
<P><b>Rec. 41</b>   Avoid functions with many arguments.
<P><b>Rec. 42</b>   If a function stores a pointer to an object which is accessed via an argument, let the argument have the type pointer. Use reference arguments in other cases.
<P><b>Rec. 43</b>   Use constant references (const &amp;) instead of call-by-value, unless using a pre-defined data type or a pointer.
<P><b>Rec. 44</b>   When overloading functions, all variations should have the same semantics (be used for the same purpose).
<P><b>Rec. 45</b>   Use inline functions when they are really needed.
<P><b>Rec. 46</b>   Minimize the number of temporary objects that are created as return values from functions or as arguments to functions.
<P><b>Rec. 47</b>   Avoid long and complex functions.
<P><b>Rec. 48</b>   Pointers to pointers should whenever possible be avoided.
<P><b>Rec. 49</b>   Use a typedef to simplify program syntax when declaring function pointers.
<P><b>Rec. 50</b>   The choice of loop construct (for, while or do-while) should depend on the specific use of the loop.
<P><b>Rec. 51</b>   Always use unsigned for variables which cannot reasonably have negative values.
<P><b>Rec. 52</b>   Always use inclusive lower limits and exclusive upper limits.
<P><b>Rec. 53</b>   Avoid the use of continue.
<P><b>Rec. 54</b>   Use break to exit a loop if this avoids the use of flags.
<P><b>Rec. 55</b>   Do not write logical expressions of the type if(test) or if(!test) when test is a pointer.
<P><b>Rec. 56</b>   Use parentheses to clarify the order of evaluation for operators in expressions.
<P><b>Rec. 57</b>   Avoid global data if at all possible.
<P><b>Rec. 58</b>   Do not allocate memory and expect that someone else will deallocate it later.
<P><b>Rec. 59</b>   Always assign a new value to a pointer that points to deallocated memory.
<P><b>Rec. 60</b>   Make sure that fault handling is done so that the transfer to exception handling (when this is available in C++) may be easily made.
<P><b>Rec. 61</b>   Check the fault codes which may be received from library functions even if these functions seem foolproof.
<P>
<a name="PortSummary"><h1>22  Summary of Portability Recommendations</h1></a>
<a href="#BackToIndex">Back to index</a>
<BR>
<P>Port. Rec. 1  Avoid the direct use of pre-defined data types in declarations.
<P>Port. Rec. 2  Do not assume that an int and a long have the same size.
<P>Port. Rec. 3  Do not assume that an int is 32 bits long (it may be only 16 bits long).
<P>Port. Rec. 4  Do not assume that a char is signed or unsigned.
<P>Port. Rec. 5  Always set char to unsigned if 8-bit ASCII is used.
<P>Port. Rec. 6  Be careful not to make type conversions from a "shorter" type to a "longer" one.
<P>Port. Rec. 7  Do not assume that pointers and integers have the same size.
<P>Port. Rec. 8  Use explicit type conversions for arithmetic using signed and unsigned values.
<P>Port. Rec. 9  Do not assume that you know how an instance of a data type is represented in memory.
<P>Port. Rec. 10  Do not assume that longs, floats, doubles or long doubles may begin at arbitrary addresses.
<P>Port. Rec. 11  Do not depend on underflow or overflow functioning in any special way.
<P>Port. Rec. 12  Do not assume that the operands in an expression are evaluated in a definite order.
<P>Port. Rec. 13  Do not assume that you know how the invocation mechanism for a function is implemented.
<P>Port. Rec. 14  Do not assume that an object is initialized in any special order in constructors.
<P>Port. Rec. 15  Do not assume that static objects are initialized in any special order.
<P>Port. Rec. 16  Do not write code which is dependent on the lifetime of a temporary object.
<P>Port. Rec. 17  Avoid using shift operations instead of arithmetic operations.
<P>Port. Rec. 18  Avoid pointer arithmetic.
<BR>
<HR>
<ADDRESS>
This version originally created by unknown parties.<BR>
Archived by Chris Lott after correcting a few HTML glitches.
<BR>
<A HREF="index.html">Collection index</A>
</ADDRESS>

</BODY>
</HTML>
